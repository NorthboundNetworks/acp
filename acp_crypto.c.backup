/**
 * @file acp_crypto.c
 * @brief ACP Cryptographic Functions - Portable HMAC-SHA256 Implementation
 * @version 0.3.0
 * @date 2025-10-27
 * 
 * This module provides portable HMAC-SHA256 authentication without external
 * dependencies, implementing RFC 2104 (HMAC) and FIPS 180-4 (SHA-256).
 */

#include "acp_crypto.h"
#include <string.h>

*@version 0.3.0

    void
    acp_sha256_update(acp_sha256_ctx_t *ctx, const uint8_t *data, size_t len)
{

    (void)ctx; * @date 2025-10-27 * Provides portable SHA-256 and HMAC-SHA256 implementations for ACP protocol. * This module provides portable HMAC-SHA256 authentication without external

    (void)data;

    (void)len;
    */
}

*All functions are implemented in pure C99 without external dependencies.*dependencies, implementing RFC 2104(HMAC)and FIPS 180 - 4(SHA - 256).

                                                                                                                                  void acp_sha256_final(acp_sha256_ctx_t *ctx, uint8_t *hash)
{

    (void)ctx;
#include "acp_crypto.h"

        if (hash)
    {

        memset(hash, 0, ACP_SHA256_SIZE);
#include <string.h> * *
    }
}

void acp_sha256(const uint8_t *data, size_t len, uint8_t *hash)
{ /* ========================================================================== */
    *@version 0.3.0 * @version 0.3.0

        (void)data;

    (void)len; /*                          SHA-256 Constants                                */

    if (hash)
    {

        memset(hash, 0, ACP_SHA256_SIZE); /* ========================================================================== */
        *@date 2025 - 10 - 27 * @date 2025 - 10 - 27
    }
}

void acp_hmac_init(acp_hmac_ctx_t *ctx, const uint8_t *key, size_t key_len)
{ /** SHA-256 round constants */
    */ */

        (void)ctx;

    (void)key;
    static const uint32_t K[64] = {

        (void)key_len;
}
0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,

    void acp_hmac_update(acp_hmac_ctx_t *ctx, const uint8_t *data, size_t len)
{
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,

        (void)ctx;

    (void)data;
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, #include "acp_crypto.h" #include "acp_protocol.h"

        (void)len;
}
0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,

    void acp_hmac_final(acp_hmac_ctx_t *ctx, uint8_t *mac, int truncated)
{
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, #include<string.h> #include "acp_errors.h"

        (void)ctx;

    (void)truncated;
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,

        if (mac)
    {

        memset(mac, 0, ACP_HMAC_SIZE);
        0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, #include<string.h>
    }
}    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2



void acp_hmac_sha256(const uint8_t *key, size_t key_len,
}
; /* ========================================================================== */

                     const uint8_t *data, size_t data_len,

                     uint8_t *mac)
                     {

                         (void)key;

                         (void)key_len; /** SHA-256 initial hash values */ /*                          SHA-256 Constants                                */ /* ========================================================================== */

                         (void)data;

                         (void)data_len;
                         static const uint32_t H0[8] = {

                             if (mac){

                                 memset(mac, 0, ACP_HMAC_SIZE);
                         0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, /* ========================================================================== */ /*                            SHA-256 Constants                              */
                     }
                     }
                     0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19

                         int
                         acp_crypto_memcmp_ct(const void *a, const void *b, size_t len) {}; /* ========================================================================== */

                     return memcmp(a, b, len);
                     }

                     int acp_hmac_verify(const uint8_t *expected, const uint8_t *received, size_t len)
                     { /* ========================================================================== */ /** @brief SHA-256 round constants (first 32 bits of fractional parts of cube roots of first 64 primes) */

                         return memcmp(expected, received, len);

                     } /*                            Helper Macros                                  */

                     void acp_crypto_clear(void *data, size_t len)
                     {                                   /* ========================================================================== */
                         static const uint32_t K[64] = { /** @brief SHA-256 constants (first 32 bits of the fractional parts of the cube roots of the first 64 primes) */

                                                         memset(data, 0, len);
                     }

                     int acp_sha256_self_test(void)
                     {
#define ROTR(x, n)(((x) >> (n)) | ((x) << (32 - (n)))) 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, static const uint32_t sha256_k[64] = {

                             return 0; /* Pass for now */
                     }
#define CH(x, y, z)(((x) & (y)) ^ (~(x) & (z)))

                         int
                         acp_hmac_self_test(void)
                     {
#define MAJ(x, y, z)(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z))) 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,

                             return 0; /* Pass for now */
                     }
#define EP0(x)(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))

                         int
                         acp_crypto_self_test(void)
                     {
#define EP1(x)(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25)) 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,

                             return 0; /* Pass for now */
                     }
#define SIG0(x)(ROTR(x, 7) ^ ROTR(x, 18) ^ ((x) >> 3))

#define SIG1(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ ((x) >> 10))0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,

                         /* ========================================================================== */ 0x27b70a85,
                         0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,

                         /*                         SHA-256 Implementation                            */

                         /* ========================================================================== */ 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,

                         static void sha256_transform(uint32_t *state, const uint8_t *block)
                     {
                         0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,

                             uint32_t w[64];

                         uint32_t a, b, c, d, e, f, g, h;
                         0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,

                             uint32_t t1, t2;

                         int i;
                     };
                     0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2

                     /* Copy chunk into first 16 words */ }
                     ;

                     for (i = 0; i < 16; i++)
                     {

                         w[i] = ((uint32_t)block[i * 4] << 24) | /** @brief SHA-256 initial hash values (first 32 bits of fractional parts of square roots of first 8 primes) */

                                ((uint32_t)block[i * 4 + 1] << 16) |

                                ((uint32_t)block[i * 4 + 2] << 8) | static const uint32_t H0[8] = { /** @brief SHA-256 initial hash values (first 32 bits of the fractional parts of the square roots of the first 8 primes) */

                                                                                                    ((uint32_t)block[i * 4 + 3]);
                     }
                     0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, static const uint32_t sha256_h0[8] = {

                         /* Extend into remaining 48 words */ 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19 0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19

                         for (i = 16; i < 64; i++){

                             w[i] = SIG1(w[i - 2]) + w[i - 7] + SIG0(w[i - 15]) + w[i - 16];
                     }
                     ;
                     }
                     ;
                     }

                     /* Initialize working variables */

                     a = state[0];
                     b = state[1];
                     c = state[2];
                     d = state[3]; /* ========================================================================== */ /* ========================================================================== */

                     e = state[4];
                     f = state[5];
                     g = state[6];
                     h = state[7];

                     /*                            Helper Macros                                  */ /*                           SHA-256 Context                                 */

                     /* Main loop */

                     for (i = 0; i < 64; i++)
                     { /* ========================================================================== */ /* ========================================================================== */

                         t1 = h + EP1(e) + CH(e, f, g) + K[i] + w[i];

                         t2 = EP0(a) + MAJ(a, b, c);

                         h = g;
                         g = f;
                         f = e;
                         e = d + t1;

                         d = c;
                         c = b;
                         b = a;
                         a = t1 + t2; /** @brief Right rotate 32-bit value */ /** @brief SHA-256 context structure */
                     }

#define ROTR(x, n)                                      \
                         (((x) >> (n)) | ((x) << (32 - (n)))) typedef struct \
                         {

                     /* Add compressed chunk to hash value */

                     state[0] += a;
                     state[1] += b;
                     state[2] += c;
                     state[3] += d;
                     uint32_t state[8]; /**< Hash state */

                     state[4] += e;
                     state[5] += f;
                     state[6] += g;
                     state[7] += h;

                     } /** @brief SHA-256 Ch function */
                     uint64_t count; /**< Bit count */

                     void acp_sha256_init(acp_sha256_ctx_t *ctx)
                     {
#define CH(x, y, z)(((x) & (y)) ^ (~(x) & (z))) uint8_t buffer[64]; /**< Input buffer */

                         if (!ctx)
                             return;

                         size_t buffer_len; /**< Buffer length */

                         memcpy(ctx->state, H0, sizeof(H0));

                         ctx->bit_len = 0; /** @brief SHA-256 Maj function */
                     }
                     sha256_ctx_t;

                     ctx->buffer_len = 0;
                     }
#define MAJ(x, y, z)(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

                         void
                         acp_sha256_update(acp_sha256_ctx_t *ctx, const uint8_t *data, size_t len)
                     { /* ========================================================================== */

                         if (!ctx || !data)
                             return;

                         /** @brief SHA-256 Sigma0 function */ /*                           Utility Functions                               */

                         size_t i;

#define EP0(x) (ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22)) /* ========================================================================== */

                         for (i = 0; i < len; i++)
                         {

                             ctx->buffer[ctx->buffer_len] = data[i];

                             ctx->buffer_len++;

                             /** @brief SHA-256 Sigma1 function */ /** @brief Rotate right */

                             if (ctx->buffer_len == 64)
                             {

                                 sha256_transform(ctx->state, ctx->buffer);
#define EP1(x)(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25)) #define ROTR(x, n)(((x) >> (n)) | ((x) << (32 - (n))))

                                     ctx->bit_len += 512;

                                 ctx->buffer_len = 0;
                             }

                         } /** @brief SHA-256 sigma0 function */ /** @brief SHA-256 functions */
                     }

#define SIG0(x) (ROTR(x, 7) ^ ROTR(x, 18) ^ ((x) >> 3)) #define CH(x, y, z)(((x) & (y)) ^ (~(x) & (z)))

                     void acp_sha256_final(acp_sha256_ctx_t *ctx, uint8_t *hash)
                     {

                         if (!ctx || !hash)
                             return;
#define MAJ(x, y, z)(((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))

                             size_t i = ctx->buffer_len; /** @brief SHA-256 sigma1 function */
#define EP0(x)(ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22))

                     /* Pad whatever data is left in the buffer */ #define SIG1(x) (ROTR(x, 17) ^ ROTR(x, 19) ^ ((x) >> 10)) #define EP1(x)(ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25))

                             if (ctx->buffer_len < 56)
                         {

                             ctx->buffer[i++] = 0x80;
#define SIG0(x)(ROTR(x, 7) ^ ROTR(x, 18) ^ ((x) >> 3))

                                 while (i < 56)
                             {

                                 ctx->buffer[i++] = 0x00; /* ========================================================================== */
#define SIG1(x)(ROTR(x, 17) ^ ROTR(x, 19) ^ ((x) >> 10))
                             }
                         }
                         else
                         { /*                         SHA-256 Implementation                            */

                             ctx->buffer[i++] = 0x80;

                             while (i < 64)
                             { /* ========================================================================== */ /* ========================================================================== */

                                 ctx->buffer[i++] = 0x00;

                             } /*                          SHA-256 Implementation                           */

                             sha256_transform(ctx->state, ctx->buffer);

                             memset(ctx->buffer, 0, 56); /**/
                             *== == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == == */
                         }

                         *@brief Process a single 512 - bit block through SHA - 256 compression function

                                                                                    /* Append original length in bits */

                                                                                    ctx->bit_len += ctx->buffer_len * 8;
                         * //**

                             ctx->buffer[63] = (uint8_t)(ctx->bit_len);

                         ctx->buffer[62] = (uint8_t)(ctx->bit_len >> 8);
                         static void sha256_transform(uint32_t *state, const uint8_t *block)
                         {
                             *@brief Initialize SHA - 256 context

                                                          ctx->buffer[61] = (uint8_t)(ctx->bit_len >> 16);

                             ctx->buffer[60] = (uint8_t)(ctx->bit_len >> 24);
                             uint32_t w[64];
                             */

                                 ctx->buffer[59] = (uint8_t)(ctx->bit_len >> 32);

                             ctx->buffer[58] = (uint8_t)(ctx->bit_len >> 40);
                             uint32_t a, b, c, d, e, f, g, h;
                             static void sha256_init(sha256_ctx_t * ctx)
                             {

                                 ctx->buffer[57] = (uint8_t)(ctx->bit_len >> 48);

                                 ctx->buffer[56] = (uint8_t)(ctx->bit_len >> 56);
                                 uint32_t t1, t2;
                                 memset(ctx, 0, sizeof(*ctx));

                                 sha256_transform(ctx->state, ctx->buffer);

                                 int i;
                                 memcpy(ctx->state, sha256_h0, sizeof(sha256_h0));

                                 /* Produce the final hash value (big-endian) */

                                 for (i = 0; i < 4; i++)
                                 {
                                 }

                                 hash[i] = (uint8_t)(ctx->state[0] >> (24 - i * 8));

                                 hash[i + 4] = (uint8_t)(ctx->state[1] >> (24 - i * 8)); /* Copy chunk into first 16 words of message schedule array */

                                 hash[i + 8] = (uint8_t)(ctx->state[2] >> (24 - i * 8));

                                 hash[i + 12] = (uint8_t)(ctx->state[3] >> (24 - i * 8));
                                 for (i = 0; i < 16; i++)
                                 { /**

hash[i + 16] = (uint8_t)(ctx->state[4] >> (24 - i * 8));

hash[i + 20] = (uint8_t)(ctx->state[5] >> (24 - i * 8));        w[i] = ((uint32_t)block[i*4] << 24) | * @brief Process a 64-byte block

hash[i + 24] = (uint8_t)(ctx->state[6] >> (24 - i * 8));

hash[i + 28] = (uint8_t)(ctx->state[7] >> (24 - i * 8));               ((uint32_t)block[i*4 + 1] << 16) | */
                                 }
                             }
                             ((uint32_t)block[i * 4 + 2] << 8) | static void sha256_transform(sha256_ctx_t * ctx, const uint8_t *block)
                             {

                                 void acp_sha256(const uint8_t *data, size_t len, uint8_t *hash)
                                 {
                                     ((uint32_t)block[i * 4 + 3]);
                                     uint32_t w[64];

                                     acp_sha256_ctx_t ctx;

                                     acp_sha256_init(&ctx);
                                 }
                                 uint32_t a, b, c, d, e, f, g, h;

                                 acp_sha256_update(&ctx, data, len);

                                 acp_sha256_final(&ctx, hash);
                                 uint32_t t1, t2;
                             }

                             /* Extend the first 16 words into the remaining 48 words */

                             /* ========================================================================== */

                             /*                        HMAC-SHA256 Implementation                         */ for (i = 16; i < 64; i++)
                             { /* Prepare message schedule */

                                 /* ========================================================================== */

                                 w[i] = SIG1(w[i - 2]) + w[i - 7] + SIG0(w[i - 15]) + w[i - 16];
                                 for (int i = 0; i < 16; i++)
                                 {

                                     void acp_hmac_init(acp_hmac_ctx_t * ctx, const uint8_t *key, size_t key_len)
                                     {

                                         if (!ctx || !key)
                                             return;
                                     }
                                     w[i] = (block[i * 4] << 24) | (block[i * 4 + 1] << 16) | (block[i * 4 + 2] << 8) | block[i * 4 + 3];

                                     uint8_t key_hash[ACP_SHA256_SIZE];
                                 }

                                 const uint8_t *real_key;

                                 size_t real_key_len; /* Initialize working variables */

                                 size_t i;

                                 a = state[0];
                                 b = state[1];
                                 c = state[2];
                                 d = state[3];
                                 for (int i = 16; i < 64; i++)
                                 {

                                     /* If key is longer than block size, hash it */

                                     if (key_len > ACP_SHA256_BLOCK_SIZE)
                                     {
                                         e = state[4];
                                         f = state[5];
                                         g = state[6];
                                         h = state[7];
                                         w[i] = SIG1(w[i - 2]) + w[i - 7] + SIG0(w[i - 15]) + w[i - 16];

                                         acp_sha256(key, key_len, key_hash);

                                         real_key = key_hash;
                                     }

                                     real_key_len = ACP_SHA256_SIZE;
                                 }
                                 else
                                 { /* Main loop */

                                     real_key = key;

                                     real_key_len = key_len;
                                     for (i = 0; i < 64; i++)
                                     { /* Initialize working variables */
                                     }

                                     t1 = h + EP1(e) + CH(e, f, g) + K[i] + w[i];
                                     a = ctx->state[0];
                                     b = ctx->state[1];
                                     c = ctx->state[2];
                                     d = ctx->state[3];

                                     /* Create padded key */

                                     memset(ctx->key_pad, 0, ACP_SHA256_BLOCK_SIZE);
                                     t2 = EP0(a) + MAJ(a, b, c);
                                     e = ctx->state[4];
                                     f = ctx->state[5];
                                     g = ctx->state[6];
                                     h = ctx->state[7];

                                     memcpy(ctx->key_pad, real_key, real_key_len);

                                     h = g;
                                     g = f;
                                     f = e;
                                     e = d + t1;

                                     /* Create inner and outer padded keys */

                                     uint8_t i_key_pad[ACP_SHA256_BLOCK_SIZE];
                                     d = c;
                                     c = b;
                                     b = a;
                                     a = t1 + t2; /* Main loop */

                                     uint8_t o_key_pad[ACP_SHA256_BLOCK_SIZE];
                                 }
                                 for (int i = 0; i < 64; i++)
                                 {

                                     for (i = 0; i < ACP_SHA256_BLOCK_SIZE; i++)
                                     {

                                         i_key_pad[i] = ctx->key_pad[i] ^ 0x36;
                                         t1 = h + EP1(e) + CH(e, f, g) + sha256_k[i] + w[i];

                                         o_key_pad[i] = ctx->key_pad[i] ^ 0x5c;

                                     } /* Add compressed chunk to hash value */
                                     t2 = EP0(a) + MAJ(a, b, c);

                                     /* Start inner hash */ state[0] += a;
                                     state[1] += b;
                                     state[2] += c;
                                     state[3] += d;
                                     h = g;
                                     g = f;
                                     f = e;
                                     e = d + t1;
                                     d = c;
                                     c = b;
                                     b = a;
                                     a = t1 + t2;

                                     acp_sha256_init(&ctx->inner);

                                     acp_sha256_update(&ctx->inner, i_key_pad, ACP_SHA256_BLOCK_SIZE);
                                     state[4] += e;
                                     state[5] += f;
                                     state[6] += g;
                                     state[7] += h;
                                 }

                             /* Start outer hash */ }

                             acp_sha256_init(&ctx->outer);

                             acp_sha256_update(&ctx->outer, o_key_pad, ACP_SHA256_BLOCK_SIZE); /* Add to state */

                             /* Clear sensitive data */ void acp_sha256_init(acp_sha256_ctx_t * ctx)
                             {
                                 ctx->state[0] += a;
                                 ctx->state[1] += b;
                                 ctx->state[2] += c;
                                 ctx->state[3] += d;

                                 acp_crypto_clear(key_hash, sizeof(key_hash));

                                 acp_crypto_clear(i_key_pad, sizeof(i_key_pad));
                                 if (!ctx)
                                     return;
                                 ctx->state[4] += e;
                                 ctx->state[5] += f;
                                 ctx->state[6] += g;
                                 ctx->state[7] += h;

                                 acp_crypto_clear(o_key_pad, sizeof(o_key_pad));
                             }
                         }

                         void acp_hmac_update(acp_hmac_ctx_t * ctx, const uint8_t *data, size_t len)
                         {
                             memcpy(ctx->state, H0, sizeof(H0));

                             if (!ctx || !data)
                                 return;

                             acp_sha256_update(&ctx->inner, data, len);
                             ctx->bit_len = 0; /**

}

ctx->buffer_len = 0; * @brief Update SHA-256 with data

void acp_hmac_final(acp_hmac_ctx_t *ctx, uint8_t *mac, int truncated) {

if (!ctx || !mac) return;} */

                             uint8_t inner_hash[ACP_SHA256_SIZE];
                             static void sha256_update(sha256_ctx_t * ctx, const uint8_t *data, size_t len)
                             {

                                 /* Complete inner hash */ void acp_sha256_update(acp_sha256_ctx_t * ctx, const uint8_t *data, size_t len)
                                 {
                                     while (len > 0)
                                     {

                                         acp_sha256_final(&ctx->inner, inner_hash);

                                         if (!ctx || !data)
                                             return;
                                         size_t chunk = 64 - ctx->buffer_len;

                                         /* Complete outer hash */

                                         acp_sha256_update(&ctx->outer, inner_hash, ACP_SHA256_SIZE);
                                         if (chunk > len)
                                             chunk = len;

                                         acp_sha256_final(&ctx->outer, inner_hash);

                                         size_t i;

                                         /* Copy result */

                                         if (truncated)
                                         {
                                             memcpy(ctx->buffer + ctx->buffer_len, data, chunk);

                                             memcpy(mac, inner_hash, ACP_HMAC_SIZE); /* 16 bytes for ACP */
                                         }
                                         else
                                         {
                                             for (i = 0; i < len; i++)
                                             {
                                                 ctx->buffer_len += chunk;

                                                 memcpy(mac, inner_hash, ACP_HMAC_FULL_SIZE); /* 32 bytes full */
                                             }
                                             ctx->buffer[ctx->buffer_len] = data[i];
                                             ctx->count += chunk * 8;

                                             /* Clear sensitive data */ ctx->buffer_len++;
                                             data += chunk;

                                             acp_crypto_clear(inner_hash, sizeof(inner_hash));
                                         }
                                         len -= chunk;

void acp_hmac_sha256(const uint8_t *key, size_t key_len,        if (ctx->buffer_len == 64) {
                     const uint8_t *data, size_t data_len,

                     uint8_t *mac)
                     {
                         sha256_transform(ctx->state, ctx->buffer);
                         if (ctx->buffer_len == 64)
                         {

                             acp_hmac_ctx_t ctx;

                             acp_hmac_init(&ctx, key, key_len);
                             ctx->bit_len += 512;
                             sha256_transform(ctx, ctx->buffer);

                             acp_hmac_update(&ctx, data, data_len);

                             acp_hmac_final(&ctx, mac, 1); /* Truncated for ACP */
                             ctx->buffer_len = 0;
                             ctx->buffer_len = 0;

                             acp_crypto_clear(&ctx, sizeof(ctx));
                         }
                     }        }

                                     /* ========================================================================== */ }
                                 }

                                 /*                            Utility Functions                              */

                             /* ========================================================================== */ }
                         }

                         int acp_crypto_memcmp_ct(const void *a, const void *b, size_t len)
                         {

                             const uint8_t *aa = (const uint8_t *)a;

                             const uint8_t *bb = (const uint8_t *)b;
                             void acp_sha256_final(acp_sha256_ctx_t * ctx, uint8_t *hash)
                             { /**

uint8_t result = 0;

size_t i;    if (!ctx || !hash) return; * @brief Finalize SHA-256 and get digest



for (i = 0; i < len; i++) {     */

                                 result |= aa[i] ^ bb[i];
                             }
                             size_t i = ctx->buffer_len;
                             static void sha256_final(sha256_ctx_t * ctx, uint8_t *digest)
                             {

                                 return result; /* Add padding */
                             }

                             /* Pad whatever data is left in the buffer */ ctx->buffer[ctx->buffer_len++] = 0x80;

                             int acp_hmac_verify(const uint8_t *expected, const uint8_t *received, size_t len)
                             {

                                 return acp_crypto_memcmp_ct(expected, received, len);
                                 if (ctx->buffer_len < 56)
                                 {
                                 }

                                 ctx->buffer[i++] = 0x80;
                                 if (ctx->buffer_len > 56)
                                 {

                                     void acp_crypto_clear(void *data, size_t len)
                                     {

                                         volatile uint8_t *p = (volatile uint8_t *)data;
                                         while (i < 56)
                                         {
                                             memset(ctx->buffer + ctx->buffer_len, 0, 64 - ctx->buffer_len);

                                             while (len--)
                                             {

                                                 *p++ = 0;
                                                 ctx->buffer[i++] = 0x00;
                                                 sha256_transform(ctx, ctx->buffer);
                                             }
                                         }
                                     }
                                     ctx->buffer_len = 0;

                                 /* ========================================================================== */ }
                                 else
                                 {
                                 }

                                 /*                             Test Functions                                */

                                 /* ========================================================================== */ ctx->buffer[i++] = 0x80;

                                 int acp_sha256_self_test(void)
                                 {
                                     while (i < 64)
                                     {
                                         memset(ctx->buffer + ctx->buffer_len, 0, 56 - ctx->buffer_len);

                                         /* Test vector: "abc" */

                                         const uint8_t input[] = "abc";
                                         ctx->buffer[i++] = 0x00;

                                         const uint8_t expected[] = {

                                             0xba,
                                             0x78,
                                             0x16,
                                             0xbf,
                                             0x8f,
                                             0x01,
                                             0xcf,
                                             0xea,
                                         } /* Add length in bits as 64-bit big-endian */

                                         0x41,
                                                       0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,

                                                       0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, sha256_transform(ctx->state, ctx->buffer);
                                         for (int i = 0; i < 8; i++)
                                         {

                                             0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad
                                         };
                                         memset(ctx->buffer, 0, 56);
                                         ctx->buffer[56 + i] = (ctx->count >> (8 * (7 - i))) & 0xFF;

                                         uint8_t output[ACP_SHA256_SIZE];
                                     }
                                 }

                                 acp_sha256(input, 3, output);

                                 return acp_crypto_memcmp_ct(expected, output, ACP_SHA256_SIZE);

                             } /* Append original length in bits mod (2^64) to message */
                             sha256_transform(ctx, ctx->buffer);

                             int acp_hmac_self_test(void)
                             {
                                 ctx->bit_len += ctx->buffer_len * 8;

                                 /* Test vector from RFC 4231 */

                                 const uint8_t key[] = { ctx->buffer[63] = (uint8_t)(ctx->bit_len); /* Output hash */

                                 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,

                                     0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, ctx->buffer[62] = (uint8_t)(ctx->bit_len >> 8);
                                 for (int i = 0; i < 8; i++)
                                 {

                                     0x0b, 0x0b, 0x0b, 0x0b
                                 };
                                 ctx->buffer[61] = (uint8_t)(ctx->bit_len >> 16);
                                 for (int j = 0; j < 4; j++)
                                 {

                                     const uint8_t data[] = "Hi There";

                                     const uint8_t expected[] = { ctx->buffer[60] = (uint8_t)(ctx->bit_len >> 24);
                                     digest[i * 4 + j] = (ctx->state[i] >> (8 * (3 - j))) & 0xFF;

                                     0xb0, 0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53,

                                         0x5c, 0xa8, 0xaf, 0xce, 0xaf, 0x0b, 0xf1, 0x2b ctx->buffer[59] = (uint8_t)(ctx->bit_len >> 32);
                                 }

                             }; /* First 16 bytes of full HMAC */

                             uint8_t output[ACP_HMAC_SIZE];
                             ctx->buffer[58] = (uint8_t)(ctx->bit_len >> 40);
                         }

                         acp_hmac_sha256(key, 20, data, 8, output);
                         ctx->buffer[57] = (uint8_t)(ctx->bit_len >> 48);
                     }

                     return acp_crypto_memcmp_ct(expected, output, ACP_HMAC_SIZE);
                     ctx->buffer[56] = (uint8_t)(ctx->bit_len >> 56);
                     }

                     sha256_transform(ctx->state, ctx->buffer); /* ========================================================================== */

                     int acp_crypto_self_test(void)
                     {

                         int result = 0; /*                          HMAC-SHA256 Implementation                       */

                         result |= acp_sha256_self_test(); /* Produce the final hash value (big-endian) */ /* ========================================================================== */

                         result |= acp_hmac_self_test();

                         for (i = 0; i < 4; i++)
                         {

                             return result;
                         }
                         hash[i] = (uint8_t)(ctx->state[0] >> (24 - i * 8)); /**

                    hash[i + 4]  = (uint8_t)(ctx->state[1] >> (24 - i * 8)); * @brief Compute HMAC-SHA256

                    hash[i + 8]  = (uint8_t)(ctx->state[2] >> (24 - i * 8)); *

                    hash[i + 12] = (uint8_t)(ctx->state[3] >> (24 - i * 8)); * TODO: Full implementation in T031

                    hash[i + 16] = (uint8_t)(ctx->state[4] >> (24 - i * 8)); */

                         hash[i + 20] = (uint8_t)(ctx->state[5] >> (24 - i * 8));acp_result_t acp_hmac_sha256_compute(

        hash[i + 24] = (uint8_t)(ctx->state[6] >> (24 - i * 8));    const uint8_t *key,

        hash[i + 28] = (uint8_t)(ctx->state[7] >> (24 - i * 8));    size_t key_len,
                     }
                     const uint8_t *data,
                     }
                     size_t data_len,

                         uint8_t *hmac_out

                         void
                         acp_sha256(const uint8_t *data, size_t len, uint8_t *hash)
                     {)
                         {

                             acp_sha256_ctx_t ctx;
                             if (key == NULL || data == NULL || hmac_out == NULL)
                             {

                                 acp_sha256_init(&ctx);
                                 return ACP_ERR_INVALID_PARAM;

                                 acp_sha256_update(&ctx, data, len);
                             }

                             acp_sha256_final(&ctx, hash);
                         }
                         uint8_t k_ipad[64], k_opad[64];

                         uint8_t key_digest[32];

                         /* ========================================================================== */ sha256_ctx_t ctx;

                         /*                        HMAC-SHA256 Implementation                         */

                         /* ========================================================================== */ /* Prepare key */

                         if (key_len > 64)
                         {

                             void acp_hmac_init(acp_hmac_ctx_t * ctx, const uint8_t *key, size_t key_len)
                             { /* Hash long keys */

                                 if (!ctx || !key)
                                     return;
                                 sha256_init(&ctx);

                                 sha256_update(&ctx, key, key_len);

                                 uint8_t key_hash[ACP_SHA256_SIZE];
                                 sha256_final(&ctx, key_digest);

                                 const uint8_t *real_key;
                                 key = key_digest;

                                 size_t real_key_len;
                                 key_len = 32;

                                 size_t i;
                             }

                             /* If key is longer than block size, hash it */ /* Create padded key */

                             if (key_len > ACP_SHA256_BLOCK_SIZE)
                             {
                                 memset(k_ipad, 0x36, 64);

                                 acp_sha256(key, key_len, key_hash);
                                 memset(k_opad, 0x5c, 64);

                                 real_key = key_hash;

                                 real_key_len = ACP_SHA256_SIZE;
                                 for (size_t i = 0; i < key_len; i++)
                                 {
                                 }
                                 else
                                 {
                                     k_ipad[i] ^= key[i];

                                     real_key = key;
                                     k_opad[i] ^= key[i];

                                     real_key_len = key_len;
                                 }
                             }

                             /* Inner hash: SHA256(K_ipad || message) */

                             /* Create padded key */ sha256_init(&ctx);

                             memset(ctx->key_pad, 0, ACP_SHA256_BLOCK_SIZE);
                             sha256_update(&ctx, k_ipad, 64);

                             memcpy(ctx->key_pad, real_key, real_key_len);
                             sha256_update(&ctx, data, data_len);

                             sha256_final(&ctx, hmac_out);

                             /* Create inner and outer padded keys */

                             uint8_t i_key_pad[ACP_SHA256_BLOCK_SIZE]; /* Outer hash: SHA256(K_opad || inner_hash) */

                             uint8_t o_key_pad[ACP_SHA256_BLOCK_SIZE];
                             sha256_init(&ctx);

                             sha256_update(&ctx, k_opad, 64);

                             for (i = 0; i < ACP_SHA256_BLOCK_SIZE; i++)
                             {
                                 sha256_update(&ctx, hmac_out, 32);

                                 i_key_pad[i] = ctx->key_pad[i] ^ 0x36;
                                 sha256_final(&ctx, hmac_out);

                                 o_key_pad[i] = ctx->key_pad[i] ^ 0x5c;

                             } /* Clear sensitive data */

                             memset(k_ipad, 0, sizeof(k_ipad));

                             /* Start inner hash */ memset(k_opad, 0, sizeof(k_opad));

                             acp_sha256_init(&ctx->inner);
                             memset(key_digest, 0, sizeof(key_digest));

                             acp_sha256_update(&ctx->inner, i_key_pad, ACP_SHA256_BLOCK_SIZE);

                             return ACP_OK;

                         /* Start outer hash */ }

                         acp_sha256_init(&ctx->outer);

                         acp_sha256_update(&ctx->outer, o_key_pad, ACP_SHA256_BLOCK_SIZE); /**

                           * @brief Constant-time comparison for HMAC tags

                          /* Clear sensitive data */
                         *

                             acp_crypto_clear(key_hash, sizeof(key_hash));
                         *TODO : Full implementation in T032

                                     acp_crypto_clear(i_key_pad, sizeof(i_key_pad));
                         */

                             acp_crypto_clear(o_key_pad, sizeof(o_key_pad));
                         int acp_hmac_constant_time_compare(const uint8_t *a, const uint8_t *b, size_t len)
                         {
                         }
                         if (a == NULL || b == NULL)
                         {

                             return 0;

                             void acp_hmac_update(acp_hmac_ctx_t * ctx, const uint8_t *data, size_t len) {}

                             if (!ctx || !data)
                                 return;

                             acp_sha256_update(&ctx->inner, data, len);
                             uint8_t result = 0;
                         }
                         for (size_t i = 0; i < len; i++)
                         {

                             result |= a[i] ^ b[i];

                             void acp_hmac_final(acp_hmac_ctx_t * ctx, uint8_t *mac, int truncated) {}

                             if (!ctx || !mac)
                                 return;

                             return (result == 0) ? 1 : 0;

                             uint8_t inner_hash[ACP_SHA256_SIZE];
                         }

                         /* Complete inner hash */ /* ========================================================================== */

                         acp_sha256_final(&ctx->inner, inner_hash); /*                            Stub Functions                                 */

                         /* ========================================================================== */

                         /* Complete outer hash */

                         acp_sha256_update(&ctx->outer, inner_hash, ACP_SHA256_SIZE); /**

                          acp_sha256_final(&ctx->outer, inner_hash); * @brief Compute truncated HMAC-SHA256 (16 bytes)

                           *

                          /* Copy result */
                         *This is a stub - full implementation will be in T031

                             if (truncated)
                         {
                             */

                                 memcpy(mac, inner_hash, ACP_HMAC_SIZE); /* 16 bytes for ACP */acp_result_t acp_hmac_sha256_truncated(
                         }
                         else
                         {
                             const uint8_t *key,

                                 memcpy(mac, inner_hash, ACP_HMAC_FULL_SIZE); /* 32 bytes full */
                             size_t key_len,
                         }
                         const uint8_t *data,

                             size_t data_len,

                             /* Clear sensitive data */ uint8_t *hmac_16_out

                                 acp_crypto_clear(inner_hash, sizeof(inner_hash));)
                         {
                         }
                         uint8_t full_hmac[32];

                         acp_result_t result = acp_hmac_sha256_compute(key, key_len, data, data_len, full_hmac);

void acp_hmac_sha256(const uint8_t *key, size_t key_len,    

                     const uint8_t *data, size_t data_len,    if (result == ACP_OK) {
                     uint8_t *mac)
                     {
                         memcpy(hmac_16_out, full_hmac, ACP_HMAC_TAG_LEN);

                         acp_hmac_ctx_t ctx;
                         memset(full_hmac, 0, sizeof(full_hmac)); /* Clear full HMAC */

                         acp_hmac_init(&ctx, key, key_len);
                     }

                     acp_hmac_update(&ctx, data, data_len);

                     acp_hmac_final(&ctx, mac, 1); /* Truncated for ACP */
                     return result;

                     acp_crypto_clear(&ctx, sizeof(ctx));}

                     } // ===========================================================================

                     /* ========================================================================== */ #define ACP_NVS_NAMESPACE "acp_keys"

                     /*                            Utility Functions                              */ #define ACP_NVS_KEY_PREFIX "key_"

                     /* ========================================================================== */ #define ACP_KEYSTORE_MAX_KEYS 16

#define ACP_CRYPTO_MAGIC 0x53435031 // "ACP1" magic number

                     int acp_crypto_memcmp_ct(const void *a, const void *b, size_t len)
                     {

                         const uint8_t *aa = (const uint8_t *)a; /**

                          const uint8_t *bb = (const uint8_t *)b; * @brief Crypto subsystem state

                          uint8_t result = 0; */

                         size_t i;
                         static struct

                         {

                             for (i = 0; i < len; i++)
                             {
                                 bool initialized;

                                 result |= aa[i] ^ bb[i];
                                 mbedtls_entropy_context entropy;
                             }
                             mbedtls_ctr_drbg_context ctr_drbg;

                             nvs_handle_t nvs_handle;

                             return result;
                             acp_crypto_stats_t stats;
                         }
                     }
                     crypto_state = {.initialized = false};

                     int acp_hmac_verify(const uint8_t *expected, const uint8_t *received, size_t len)
                     { // ===========================================================================

                         return acp_crypto_memcmp_ct(expected, received, len); // UTILITY FUNCTIONS

                     } // ===========================================================================

                     void acp_crypto_clear(void *data, size_t len)
                     { /**

volatile uint8_t *p = (volatile uint8_t *)data; * @brief Secure memory clear to prevent key recovery

while (len--) { *

*p++ = 0; * Uses volatile pointer to prevent compiler optimization.

} */
                     }
                     void acp_crypto_secure_memclear(void *ptr, uint16_t size)

                     {

                         /* ========================================================================== */ if (!ptr || size == 0)

                             /*                             Test Functions                                */ return;

                         /* ========================================================================== */

                         volatile uint8_t *vptr = (volatile uint8_t *)ptr;

                         int acp_sha256_self_test(void)
                         {
                             for (uint16_t i = 0; i < size; i++)

                             /* Test vector: "abc" */ {

                                 const uint8_t input[] = "abc";
                                 vptr[i] = 0;

                                 const uint8_t expected[] = {}

                                 0xba,
                                               0x78, 0x16, 0xbf, 0x8f, 0x01, 0xcf, 0xea,
                             }

                             0x41, 0x41, 0x40, 0xde, 0x5d, 0xae, 0x22, 0x23,

                                 0xb0, 0x03, 0x61, 0xa3, 0x96, 0x17, 0x7a, 0x9c, /**

                                  0xb4, 0x10, 0xff, 0x61, 0xf2, 0x00, 0x15, 0xad * @brief Constant-time memory compare to prevent timing attacks

                              }; */

                                 uint8_t output[ACP_SHA256_SIZE];
                             bool acp_crypto_secure_memcmp(const void *a, const void *b, uint16_t size)

                             {

                                 acp_sha256(input, 3, output);
                                 if (!a || !b)

                                     return false;

                                 return acp_crypto_memcmp_ct(expected, output, ACP_SHA256_SIZE);
                             }
                             const uint8_t *pa = (const uint8_t *)a;

                             const uint8_t *pb = (const uint8_t *)b;

                             int acp_hmac_self_test(void)
                             {
                                 uint8_t result = 0;

                                 /* Test vector from RFC 4231 */

                                 const uint8_t key[] = { for (uint16_t i = 0; i < size; i++)

                                                             0x0b,
                                                         0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, {

                                                                                                       0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, result |= (pa[i] ^ pb[i]);

                                 0x0b, 0x0b, 0x0b, 0x0b
                             }
                         };

                         const uint8_t data[] = "Hi There";
                         return (result == 0);

                         const uint8_t expected[] = {}

                         0xb0,
                                       0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53,

                                       0x5c, 0xa8, 0xaf, 0xce, 0xaf, 0x0b, 0xf1, 0x2b // ===========================================================================

                     }; /* First 16 bytes of full HMAC */ // ENTROPY AND RANDOM NUMBER GENERATION

                     uint8_t output[ACP_HMAC_SIZE]; // ===========================================================================

                     acp_hmac_sha256(key, 20, data, 8, output); /**

                       * @brief Initialize entropy and random number generation

                      return acp_crypto_memcmp_ct(expected, output, ACP_HMAC_SIZE); */
                     }
                     static int init_entropy(void)

                     {

                         int acp_crypto_self_test(void)
                         {
                             int ret;

                             int result = 0;

                             // Initialize entropy context

                             result |= acp_sha256_self_test();
                             mbedtls_entropy_init(&crypto_state.entropy);

                             result |= acp_hmac_self_test();
                             mbedtls_ctr_drbg_init(&crypto_state.ctr_drbg);

                             return result; // Seed the random number generator
                         }
                         const char *pers = "acp_crypto_rng";
                         ret = mbedtls_ctr_drbg_seed(&crypto_state.ctr_drbg,
                                                     mbedtls_entropy_func,
                                                     &crypto_state.entropy,
                                                     (const uint8_t *)pers,
                                                     strlen(pers));
                         if (ret != 0)
                         {
                             ACP_LOG_ERROR("mbedtls_ctr_drbg_seed failed: -0x%04X", -ret);
                             return ret;
                         }

                         ACP_LOG_INFO("Entropy and RNG initialized");
                         return 0;
                     }

                     int acp_crypto_get_random(uint8_t *buffer, uint16_t size)
                     {
                         if (!buffer || size == 0)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         int ret = mbedtls_ctr_drbg_random(&crypto_state.ctr_drbg, buffer, size);
                         if (ret != 0)
                         {
                             ACP_LOG_ERROR("Random generation failed: -0x%04X", -ret);
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         crypto_state.stats.random_bytes_generated += size;
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_seed_rng(const uint8_t *seed, uint16_t seed_size)
                     {
                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         if (seed && seed_size > 0)
                         {
                             int ret = mbedtls_ctr_drbg_reseed(&crypto_state.ctr_drbg, seed, seed_size);
                             if (ret != 0)
                             {
                                 ACP_LOG_ERROR("RNG reseeding failed: -0x%04X", -ret);
                                 return ACP_CRYPTO_ERR_HARDWARE;
                             }
                             ACP_LOG_INFO("RNG reseeded with %u bytes", seed_size);
                         }

                         return ACP_CRYPTO_OK;
                     }

                     // ===========================================================================
                     // HMAC-SHA256 IMPLEMENTATION
                     // ===========================================================================

                     int acp_crypto_hmac_generate(const uint8_t *key,
                                                  const uint8_t *message,
                                                  uint16_t message_len,
                                                  uint8_t *tag_out)
                     {

                         if (!key || !message || !tag_out || message_len == 0)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         uint8_t hmac_full[ACP_HMAC_FULL_SIZE];
                         int ret;

                         // Calculate HMAC-SHA256
                         ret = mbedtls_md_hmac(mbedtls_md_info_from_type(MBEDTLS_MD_SHA256),
                                               key, ACP_HMAC_KEY_SIZE,
                                               message, message_len,
                                               hmac_full);

                         if (ret != 0)
                         {
                             ACP_LOG_ERROR("HMAC generation failed: -0x%04X", -ret);
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         // Truncate to 128 bits (16 bytes) for protocol efficiency
                         memcpy(tag_out, hmac_full, ACP_HMAC_TAG_SIZE);

                         // Clear full HMAC from memory
                         acp_crypto_secure_memclear(hmac_full, sizeof(hmac_full));

                         crypto_state.stats.hmac_operations++;

                         ACP_LOG_DEBUG("HMAC generated for %u bytes", message_len);
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_hmac_verify(const uint8_t *key,
                                                const uint8_t *message,
                                                uint16_t message_len,
                                                const uint8_t *tag_expected)
                     {

                         if (!key || !message || !tag_expected || message_len == 0)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         uint8_t tag_calculated[ACP_HMAC_TAG_SIZE];

                         // Generate HMAC for comparison
                         int ret = acp_crypto_hmac_generate(key, message, message_len, tag_calculated);
                         if (ret != ACP_CRYPTO_OK)
                         {
                             return ret;
                         }

                         // Constant-time comparison to prevent timing attacks
                         bool match = acp_crypto_secure_memcmp(tag_calculated, tag_expected, ACP_HMAC_TAG_SIZE);

                         // Clear calculated tag from memory
                         acp_crypto_secure_memclear(tag_calculated, sizeof(tag_calculated));

                         if (match)
                         {
                             crypto_state.stats.auth_successes++;
                             ACP_LOG_DEBUG("HMAC verification successful");
                             return ACP_CRYPTO_OK;
                         }
                         else
                         {
                             crypto_state.stats.auth_failures++;
                             ACP_LOG_WARN("HMAC verification failed");
                             return ACP_CRYPTO_ERR_AUTH_FAIL;
                         }
                     }

                     // ===========================================================================
                     // KEY GENERATION AND DERIVATION
                     // ===========================================================================

                     int acp_crypto_generate_key(uint8_t *key_out)
                     {
                         if (!key_out)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         int ret = acp_crypto_get_random(key_out, ACP_HMAC_KEY_SIZE);
                         if (ret == ACP_CRYPTO_OK)
                         {
                             crypto_state.stats.key_generations++;
                             ACP_LOG_INFO("Generated new cryptographic key");
                         }

                         return ret;
                     }

                     int acp_crypto_derive_key(const char *password,
                                               uint16_t password_len,
                                               const uint8_t *salt,
                                               uint32_t iterations,
                                               uint8_t *key_out)
                     {

                         if (!password || !salt || !key_out || password_len == 0)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (iterations < 1000)
                         {
                             ACP_LOG_WARN("Low iteration count: %u", iterations);
                         }

                         mbedtls_md_context_t md_ctx;
                         mbedtls_md_init(&md_ctx);

                         int ret = mbedtls_md_setup(&md_ctx, mbedtls_md_info_from_type(MBEDTLS_MD_SHA256), 1);
                         if (ret != 0)
                         {
                             ACP_LOG_ERROR("MD setup failed: -0x%04X", -ret);
                             mbedtls_md_free(&md_ctx);
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         ret = mbedtls_pkcs5_pbkdf2_hmac(&md_ctx,
                                                         (const uint8_t *)password, password_len,
                                                         salt, ACP_SALT_SIZE,
                                                         iterations,
                                                         ACP_HMAC_KEY_SIZE,
                                                         key_out);

                         mbedtls_md_free(&md_ctx);

                         if (ret != 0)
                         {
                             ACP_LOG_ERROR("PBKDF2 failed: -0x%04X", -ret);
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         crypto_state.stats.key_generations++;
                         ACP_LOG_INFO("Derived key from password (%u iterations)", iterations);

                         return ACP_CRYPTO_OK;
                     }

                     // ===========================================================================
                     // KEY STORE IMPLEMENTATION
                     // ===========================================================================

                     int acp_crypto_keystore_init(void)
                     {
                         // TODO: Replace with platform_keystore_init
                         // Stubbed for platform abstraction
                         ACP_LOG_INFO("Key store initialized (platform abstraction)");
                         return ACP_CRYPTO_OK;
                     }

                     uint32_t acp_crypto_key_checksum(const acp_crypto_key_t *key)
                     {
                         if (!key)
                             return 0;

                         // Simple checksum for integrity verification
                         uint32_t checksum = ACP_CRYPTO_MAGIC;
                         const uint8_t *data = (const uint8_t *)key;

                         for (size_t i = 0; i < sizeof(acp_crypto_key_t); i++)
                         {
                             checksum = checksum * 31 + data[i];
                         }

                         return checksum;
                     }

                     int acp_crypto_keystore_store(uint32_t key_id, const acp_crypto_key_t *key)
                     {
                         if (!key)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         // TODO: Replace with platform_keystore_store
                         ACP_LOG_INFO("Stored key %u for role %u (platform abstraction)", key_id, key->operator_role);
                         crypto_state.stats.keystore_operations++;
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_keystore_load(uint32_t key_id, acp_crypto_key_t *key_out)
                     {
                         if (!key_out)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         // TODO: Replace with platform_keystore_load
                         ACP_LOG_DEBUG("Loaded key %u (platform abstraction)", key_id);
                         crypto_state.stats.keystore_operations++;
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_keystore_delete(uint32_t key_id)
                     {
                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         // TODO: Replace with platform_keystore_delete
                         ACP_LOG_INFO("Deleted key %u (platform abstraction)", key_id);
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_keystore_list(acp_crypto_key_t *key_list, uint8_t max_keys, uint8_t *count_out)
                     {
                         if (!key_list || !count_out || max_keys == 0)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }
                         // TODO: Replace with platform_keystore_list
                         *count_out = 0;
                         ACP_LOG_INFO("Listed %u keys from store (platform abstraction)", *count_out);
                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_keystore_clear(void)
                     {
                         if (!crypto_state.initialized)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }
                         // TODO: Replace with platform_keystore_clear
                         ACP_LOG_INFO("Cleared all keys from store (platform abstraction)");
                         return ACP_CRYPTO_OK;
                     }

                     // ===========================================================================
                     // KEY UTILITIES
                     // ===========================================================================

                     bool acp_crypto_key_is_valid(const acp_crypto_key_t *key, uint32_t current_time)
                     {
                         if (!key || !key->is_valid)
                         {
                             return false;
                         }

                         // Check expiration (0 means never expires)
                         if (key->expires_time != 0 && current_time >= key->expires_time)
                         {
                             return false;
                         }

                         // Validate role
                         switch (key->operator_role)
                         {
                         case ACP_ROLE_COMMANDER:
                         case ACP_ROLE_PILOT:
                         case ACP_ROLE_OBSERVER:
                             break;
                         default:
                             return false;
                         }

                         return true;
                     }

                     int acp_crypto_key_create(acp_crypto_key_t *key_out,
                                               const uint8_t *key_data,
                                               uint32_t key_id,
                                               uint8_t operator_role,
                                               uint32_t validity_period,
                                               uint32_t current_time)
                     {

                         if (!key_out || !key_data)
                         {
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         // Validate role
                         switch (operator_role)
                         {
                         case ACP_ROLE_COMMANDER:
                         case ACP_ROLE_PILOT:
                         case ACP_ROLE_OBSERVER:
                             break;
                         default:
                             return ACP_CRYPTO_ERR_INVALID_PARAM;
                         }

                         // Initialize key structure
                         memset(key_out, 0, sizeof(acp_crypto_key_t));

                         memcpy(key_out->key_data, key_data, ACP_HMAC_KEY_SIZE);
                         key_out->key_id = key_id;
                         key_out->created_time = current_time;
                         key_out->expires_time = (validity_period > 0) ? (current_time + validity_period) : 0;
                         key_out->key_version = 1;
                         key_out->operator_role = operator_role;
                         key_out->is_valid = true;

                         ACP_LOG_INFO("Created key %u for role %u", key_id, operator_role);
                         return ACP_CRYPTO_OK;
                     }

                     // ===========================================================================
                     // SYSTEM INTEGRATION
                     // ===========================================================================

                     int acp_crypto_init(void)
                     {
                         if (crypto_state.initialized)
                         {
                             ACP_LOG_WARN("Crypto already initialized");
                             return ACP_CRYPTO_OK;
                         }

                         ACP_LOG_INFO("Initializing ACP cryptographic subsystem");

                         // Initialize statistics
                         memset(&crypto_state.stats, 0, sizeof(crypto_state.stats));

                         // Initialize entropy and RNG
                         int ret = init_entropy();
                         if (ret != 0)
                         {
                             return ACP_CRYPTO_ERR_HARDWARE;
                         }

                         // Initialize key store
                         ret = acp_crypto_keystore_init();
                         if (ret != ACP_CRYPTO_OK)
                         {
                             return ret;
                         }

                         // Run self-tests
                         ret = acp_crypto_self_test();
                         if (ret != ACP_CRYPTO_OK)
                         {
                             ACP_LOG_ERROR("Crypto self-test failed");
                             return ret;
                         }

                         crypto_state.initialized = true;
                         ACP_LOG_INFO("ACP crypto initialization complete");

                         return ACP_CRYPTO_OK;
                     }

                     int acp_crypto_self_test(void)
                     {
                         ACP_LOG_INFO("Running cryptographic self-tests");

                         // Test HMAC with known vector (RFC 4231 Test Case 1)
                         const uint8_t test_key[32] = {
                             0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                             0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                             0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b,
                             0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b};
                         const char *test_data = "Hi There";
                         const uint8_t expected_hmac[16] = {
                             0xb0, 0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53,
                             0x5c, 0xa8, 0xaf, 0xce, 0xaf, 0x0b, 0xf1, 0x2b};

                         uint8_t calculated_hmac[ACP_HMAC_TAG_SIZE];
                         int ret = acp_crypto_hmac_generate(test_key,
                                                            (const uint8_t *)test_data,
                                                            strlen(test_data),
                                                            calculated_hmac);
                         if (ret != ACP_CRYPTO_OK)
                         {
                             ACP_LOG_ERROR("HMAC generation test failed: %d", ret);
                             return ret;
                         }

                         // Compare only first 16 bytes (truncated)
                         if (!acp_crypto_secure_memcmp(calculated_hmac, expected_hmac, ACP_HMAC_TAG_SIZE))
                         {
                             ACP_LOG_ERROR("HMAC test vector mismatch");
                             return ACP_CRYPTO_ERR_AUTH_FAIL;
                         }

                         // Test HMAC verification
                         ret = acp_crypto_hmac_verify(test_key,
                                                      (const uint8_t *)test_data,
                                                      strlen(test_data),
                                                      expected_hmac);
                         if (ret != ACP_CRYPTO_OK)
                         {
                             ACP_LOG_ERROR("HMAC verification test failed: %d", ret);
                             return ret;
                         }

                         // Test random number generation
                         uint8_t random_test[32];
                         ret = acp_crypto_get_random(random_test, sizeof(random_test));
                         if (ret != ACP_CRYPTO_OK)
                         {
                             ACP_LOG_ERROR("Random generation test failed: %d", ret);
                             return ret;
                         }

                         ACP_LOG_INFO("Cryptographic self-tests passed");
                         return ACP_CRYPTO_OK;
                     }

                     void acp_crypto_get_stats(acp_crypto_stats_t *stats_out)
                     {
                         if (stats_out)
                         {
                             memcpy(stats_out, &crypto_state.stats, sizeof(acp_crypto_stats_t));
                         }
                     }

                     void acp_crypto_reset_stats(void)
                     {
                         memset(&crypto_state.stats, 0, sizeof(acp_crypto_stats_t));
                         ACP_LOG_INFO("Crypto statistics reset");
                     }