<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACP - Autonomous Command Protocol: Specification-Driven Development (SDD)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACP - Autonomous Command Protocol<span id="projectnumber">&#160;v0.3.0</span>
   </div>
   <div id="projectbrief">Portable C99 framing library with COBS, CRC16, and HMAC-SHA256 authentication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2paulzanna_2_github_2_scout_2docs_2_speckit-approach.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Specification-Driven Development (SDD) </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md8351"></a></p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8352"></a>
The Power Inversion</h1>
<p>For decades, code has been king. Specifications served code—they were the scaffolding we built and then discarded once the "real work" of coding began. We wrote PRDs to guide development, created design docs to inform implementation, drew diagrams to visualize architecture. But these were always subordinate to the code itself. Code was truth. Everything else was, at best, good intentions. Code was the source of truth, and as it moved forward, specs rarely kept pace. As the asset (code) and the implementation are one, it's not easy to have a parallel implementation without trying to build from the code.</p>
<p>Spec-Driven Development (SDD) inverts this power structure. Specifications don't serve code—code serves specifications. The Product Requirements Document (PRD) isn't a guide for implementation; it's the source that generates implementation. Technical plans aren't documents that inform coding; they're precise definitions that produce code. This isn't an incremental improvement to how we build software. It's a fundamental rethinking of what drives development.</p>
<p>The gap between specification and implementation has plagued software development since its inception. We've tried to bridge it with better documentation, more detailed requirements, stricter processes. These approaches fail because they accept the gap as inevitable. They try to narrow it but never eliminate it. SDD eliminates the gap by making specifications and their concrete implementation plans born from the specification executable. When specifications and implementation plans generate code, there is no gap—only transformation.</p>
<p>This transformation is now possible because AI can understand and implement complex specifications, and create detailed implementation plans. But raw AI generation without structure produces chaos. SDD provides that structure through specifications and subsequent implementation plans that are precise, complete, and unambiguous enough to generate working systems. The specification becomes the primary artifact. Code becomes its expression (as an implementation from the implementation plan) in a particular language and framework.</p>
<p>In this new world, maintaining software means evolving specifications. The intent of the development team is expressed in natural language ("**intent-driven development**"), design assets, core principles and other guidelines. The <b>lingua franca</b> of development moves to a higher level, and code is the last-mile approach.</p>
<p>Debugging means fixing specifications and their implementation plans that generate incorrect code. Refactoring means restructuring for clarity. The entire development workflow reorganizes around specifications as the central source of truth, with implementation plans and code as the continuously regenerated output. Updating apps with new features or creating a new parallel implementation because we are creative beings, means revisiting the specification and creating new implementation plans. This process is therefore a 0 -&gt; 1, (1', ..), 2, 3, N.</p>
<p>The development team focuses in on their creativity, experimentation, their critical thinking.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8353"></a>
The SDD Workflow in Practice</h1>
<p>The workflow begins with an idea—often vague and incomplete. Through iterative dialogue with AI, this idea becomes a comprehensive PRD. The AI asks clarifying questions, identifies edge cases, and helps define precise acceptance criteria. What might take days of meetings and documentation in traditional development happens in hours of focused specification work. This transforms the traditional SDLC—requirements and design become continuous activities rather than discrete phases. This is supportive of a <b>team process</b>, where team-reviewed specifications are expressed and versioned, created in branches, and merged.</p>
<p>When a product manager updates acceptance criteria, implementation plans automatically flag affected technical decisions. When an architect discovers a better pattern, the PRD updates to reflect new possibilities.</p>
<p>Throughout this specification process, research agents gather critical context. They investigate library compatibility, performance benchmarks, and security implications. Organizational constraints are discovered and applied automatically—your company's database standards, authentication requirements, and deployment policies seamlessly integrate into every specification.</p>
<p>From the PRD, AI generates implementation plans that map requirements to technical decisions. Every technology choice has documented rationale. Every architectural decision traces back to specific requirements. Throughout this process, consistency validation continuously improves quality. AI analyzes specifications for ambiguity, contradictions, and gaps—not as a one-time gate, but as an ongoing refinement.</p>
<p>Code generation begins as soon as specifications and their implementation plans are stable enough, but they do not have to be "complete." Early generations might be exploratory—testing whether the specification makes sense in practice. Domain concepts become data models. User stories become API endpoints. Acceptance scenarios become tests. This merges development and testing through specification—test scenarios aren't written after code, they're part of the specification that generates both implementation and tests.</p>
<p>The feedback loop extends beyond initial development. Production metrics and incidents don't just trigger hotfixes—they update specifications for the next regeneration. Performance bottlenecks become new non-functional requirements. Security vulnerabilities become constraints that affect all future generations. This iterative dance between specification, implementation, and operational reality is where true understanding emerges and where the traditional SDLC transforms into a continuous evolution.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8354"></a>
Why SDD Matters Now</h1>
<p>Three trends make SDD not just possible but necessary:</p>
<p>First, AI capabilities have reached a threshold where natural language specifications can reliably generate working code. This isn't about replacing developers—it's about amplifying their effectiveness by automating the mechanical translation from specification to implementation. It can amplify exploration and creativity, support "start-over" easily, and support addition, subtraction, and critical thinking.</p>
<p>Second, software complexity continues to grow exponentially. Modern systems integrate dozens of services, frameworks, and dependencies. Keeping all these pieces aligned with original intent through manual processes becomes increasingly difficult. SDD provides systematic alignment through specification-driven generation. Frameworks may evolve to provide AI-first support, not human-first support, or architect around reusable components.</p>
<p>Third, the pace of change accelerates. Requirements change far more rapidly today than ever before. Pivoting is no longer exceptional—it's expected. Modern product development demands rapid iteration based on user feedback, market conditions, and competitive pressures. Traditional development treats these changes as disruptions. Each pivot requires manually propagating changes through documentation, design, and code. The result is either slow, careful updates that limit velocity, or fast, reckless changes that accumulate technical debt.</p>
<p>SDD can support what-if/simulation experiments: "If we need to re-implement or change the application to promote a business need to sell more T-shirts, how would we implement and experiment for that?"</p>
<p>SDD transforms requirement changes from obstacles into normal workflow. When specifications drive implementation, pivots become systematic regenerations rather than manual rewrites. Change a core requirement in the PRD, and affected implementation plans update automatically. Modify a user story, and corresponding API endpoints regenerate. This isn't just about initial development—it's about maintaining engineering velocity through inevitable changes.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8355"></a>
Core Principles</h1>
<p><b>Specifications as the Lingua Franca</b>: The specification becomes the primary artifact. Code becomes its expression in a particular language and framework. Maintaining software means evolving specifications.</p>
<p><b>Executable Specifications</b>: Specifications must be precise, complete, and unambiguous enough to generate working systems. This eliminates the gap between intent and implementation.</p>
<p><b>Continuous Refinement</b>: Consistency validation happens continuously, not as a one-time gate. AI analyzes specifications for ambiguity, contradictions, and gaps as an ongoing process.</p>
<p><b>Research-Driven Context</b>: Research agents gather critical context throughout the specification process, investigating technical options, performance implications, and organizational constraints.</p>
<p><b>Bidirectional Feedback</b>: Production reality informs specification evolution. Metrics, incidents, and operational learnings become inputs for specification refinement.</p>
<p><b>Branching for Exploration</b>: Generate multiple implementation approaches from the same specification to explore different optimization targets—performance, maintainability, user experience, cost.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8356"></a>
Implementation Approaches</h1>
<p>Today, practicing SDD requires assembling existing tools and maintaining discipline throughout the process. The methodology can be practiced with:</p>
<ul>
<li>AI assistants for iterative specification development</li>
<li>Research agents for gathering technical context</li>
<li>Code generation tools for translating specifications to implementation</li>
<li>Version control systems adapted for specification-first workflows</li>
<li>Consistency checking through AI analysis of specification documents</li>
</ul>
<p>The key is treating specifications as the source of truth, with code as the generated output that serves the specification rather than the other way around.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8357"></a>
Streamlining SDD with Commands</h1>
<p>The SDD methodology is significantly enhanced through three powerful commands that automate the specification → planning → tasking workflow:</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8358"></a>
The <span class="tt">/speckit.specify</span> Command</h2>
<p>This command transforms a simple feature description (the user-prompt) into a complete, structured specification with automatic repository management:</p>
<ol type="1">
<li><b>Automatic Feature Numbering</b>: Scans existing specs to determine the next feature number (e.g., 001, 002, 003)</li>
<li><b>Branch Creation</b>: Generates a semantic branch name from your description and creates it automatically</li>
<li><b>Template-Based Generation</b>: Copies and customizes the feature specification template with your requirements</li>
<li><b>Directory Structure</b>: Creates the proper <span class="tt">specs/[branch-name]/</span> structure for all related documents</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8359"></a>
The <span class="tt">/speckit.plan</span> Command</h2>
<p>Once a feature specification exists, this command creates a comprehensive implementation plan:</p>
<ol type="1">
<li><b>Specification Analysis</b>: Reads and understands the feature requirements, user stories, and acceptance criteria</li>
<li><b>Constitutional Compliance</b>: Ensures alignment with project constitution and architectural principles</li>
<li><b>Technical Translation</b>: Converts business requirements into technical architecture and implementation details</li>
<li><b>Detailed Documentation</b>: Generates supporting documents for data models, API contracts, and test scenarios</li>
<li><b>Quickstart Validation</b>: Produces a quickstart guide capturing key validation scenarios</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8360"></a>
The <span class="tt">/speckit.tasks</span> Command</h2>
<p>After a plan is created, this command analyzes the plan and related design documents to generate an executable task list:</p>
<ol type="1">
<li><b>Inputs</b>: Reads <span class="tt">plan.md</span> (required) and, if present, <span class="tt">data-model.md</span>, <span class="tt">contracts/</span>, and <span class="tt">research.md</span></li>
<li><b>Task Derivation</b>: Converts contracts, entities, and scenarios into specific tasks</li>
<li><b>Parallelization</b>: Marks independent tasks <span class="tt">[P]</span> and outlines safe parallel groups</li>
<li><b>Output</b>: Writes <span class="tt">tasks.md</span> in the feature directory, ready for execution by a Task agent</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8361"></a>
Example: Building a Chat Feature</h2>
<p>Here's how these commands transform the traditional development workflow:</p>
<p><b>Traditional Approach:</b></p>
<div class="fragment"><div class="line">1. Write a PRD in a document (2-3 hours)</div>
<div class="line">2. Create design documents (2-3 hours)</div>
<div class="line">3. Set up project structure manually (30 minutes)</div>
<div class="line">4. Write technical specifications (3-4 hours)</div>
<div class="line">5. Create test plans (2 hours)</div>
<div class="line">Total: ~12 hours of documentation work</div>
</div><!-- fragment --><p><b>SDD with Commands Approach:</b></p>
<div class="fragment"><div class="line"># Step 1: Create the feature specification (5 minutes)</div>
<div class="line">/speckit.specify Real-time chat system with message history and user presence</div>
<div class="line"> </div>
<div class="line"># This automatically:</div>
<div class="line"># - Creates branch &quot;003-chat-system&quot;</div>
<div class="line"># - Generates specs/003-chat-system/spec.md</div>
<div class="line"># - Populates it with structured requirements</div>
<div class="line"> </div>
<div class="line"># Step 2: Generate implementation plan (5 minutes)</div>
<div class="line">/speckit.plan WebSocket for real-time messaging, PostgreSQL for history, Redis for presence</div>
<div class="line"> </div>
<div class="line"># Step 3: Generate executable tasks (5 minutes)</div>
<div class="line">/speckit.tasks</div>
<div class="line"> </div>
<div class="line"># This automatically creates:</div>
<div class="line"># - specs/003-chat-system/plan.md</div>
<div class="line"># - specs/003-chat-system/research.md (WebSocket library comparisons)</div>
<div class="line"># - specs/003-chat-system/data-model.md (Message and User schemas)</div>
<div class="line"># - specs/003-chat-system/contracts/ (WebSocket events, REST endpoints)</div>
<div class="line"># - specs/003-chat-system/quickstart.md (Key validation scenarios)</div>
<div class="line"># - specs/003-chat-system/tasks.md (Task list derived from the plan)</div>
</div><!-- fragment --><p>In 15 minutes, you have:</p>
<ul>
<li>A complete feature specification with user stories and acceptance criteria</li>
<li>A detailed implementation plan with technology choices and rationale</li>
<li>API contracts and data models ready for code generation</li>
<li>Comprehensive test scenarios for both automated and manual testing</li>
<li>All documents properly versioned in a feature branch</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8362"></a>
The Power of Structured Automation</h2>
<p>These commands don't just save time—they enforce consistency and completeness:</p>
<ol type="1">
<li><b>No Forgotten Details</b>: Templates ensure every aspect is considered, from non-functional requirements to error handling</li>
<li><b>Traceable Decisions</b>: Every technical choice links back to specific requirements</li>
<li><b>Living Documentation</b>: Specifications stay in sync with code because they generate it</li>
<li><b>Rapid Iteration</b>: Change requirements and regenerate plans in minutes, not days</li>
</ol>
<p>The commands embody SDD principles by treating specifications as executable artifacts rather than static documents. They transform the specification process from a necessary evil into the driving force of development.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8363"></a>
Template-Driven Quality: How Structure Constrains LLMs for Better Outcomes</h2>
<p>The true power of these commands lies not just in automation, but in how the templates guide LLM behavior toward higher-quality specifications. The templates act as sophisticated prompts that constrain the LLM's output in productive ways:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8364"></a>
1. <b>Preventing Premature Implementation Details</b></h3>
<p>The feature specification template explicitly instructs:</p>
<div class="fragment"><div class="line">- ✅ Focus on WHAT users need and WHY</div>
<div class="line">- ❌ Avoid HOW to implement (no tech stack, APIs, code structure)</div>
</div><!-- fragment --><p>This constraint forces the LLM to maintain proper abstraction levels. When an LLM might naturally jump to "implement using React with Redux," the template keeps it focused on "users need real-time updates of their data." This separation ensures specifications remain stable even as implementation technologies change.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8365"></a>
2. <b>Forcing Explicit Uncertainty Markers</b></h3>
<p>Both templates mandate the use of <span class="tt">[NEEDS CLARIFICATION]</span> markers:</p>
<div class="fragment"><div class="line">When creating this spec from a user prompt:</div>
<div class="line">1. **Mark all ambiguities**: Use [NEEDS CLARIFICATION: specific question]</div>
<div class="line">2. **Don&#39;t guess**: If the prompt doesn&#39;t specify something, mark it</div>
</div><!-- fragment --><p>This prevents the common LLM behavior of making plausible but potentially incorrect assumptions. Instead of guessing that a "login system" uses email/password authentication, the LLM must mark it as <span class="tt">[NEEDS CLARIFICATION: auth method not specified - email/password, SSO, OAuth?]</span>.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8366"></a>
3. <b>Structured Thinking Through Checklists</b></h3>
<p>The templates include comprehensive checklists that act as "unit tests" for the specification:</p>
<div class="fragment"><div class="line">### Requirement Completeness</div>
<div class="line">- [ ] No [NEEDS CLARIFICATION] markers remain</div>
<div class="line">- [ ] Requirements are testable and unambiguous</div>
<div class="line">- [ ] Success criteria are measurable</div>
</div><!-- fragment --><p>These checklists force the LLM to self-review its output systematically, catching gaps that might otherwise slip through. It's like giving the LLM a quality assurance framework.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8367"></a>
4. <b>Constitutional Compliance Through Gates</b></h3>
<p>The implementation plan template enforces architectural principles through phase gates:</p>
<div class="fragment"><div class="line">### Phase -1: Pre-Implementation Gates</div>
<div class="line">#### Simplicity Gate (Article VII)</div>
<div class="line">- [ ] Using ≤3 projects?</div>
<div class="line">- [ ] No future-proofing?</div>
<div class="line">#### Anti-Abstraction Gate (Article VIII)</div>
<div class="line">- [ ] Using framework directly?</div>
<div class="line">- [ ] Single model representation?</div>
</div><!-- fragment --><p>These gates prevent over-engineering by making the LLM explicitly justify any complexity. If a gate fails, the LLM must document why in the "Complexity Tracking" section, creating accountability for architectural decisions.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8368"></a>
5. <b>Hierarchical Detail Management</b></h3>
<p>The templates enforce proper information architecture:</p>
<div class="fragment"><div class="line">**IMPORTANT**: This implementation plan should remain high-level and readable.</div>
<div class="line">Any code samples, detailed algorithms, or extensive technical specifications</div>
<div class="line">must be placed in the appropriate `implementation-details/` file</div>
</div><!-- fragment --><p>This prevents the common problem of specifications becoming unreadable code dumps. The LLM learns to maintain appropriate detail levels, extracting complexity to separate files while keeping the main document navigable.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8369"></a>
6. <b>Test-First Thinking</b></h3>
<p>The implementation template enforces test-first development:</p>
<div class="fragment"><div class="line">### File Creation Order</div>
<div class="line">1. Create `contracts/` with API specifications</div>
<div class="line">2. Create test files in order: contract → integration → e2e → unit</div>
<div class="line">3. Create source files to make tests pass</div>
</div><!-- fragment --><p>This ordering constraint ensures the LLM thinks about testability and contracts before implementation, leading to more robust and verifiable specifications.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8370"></a>
7. <b>Preventing Speculative Features</b></h3>
<p>Templates explicitly discourage speculation:</p>
<div class="fragment"><div class="line">- [ ] No speculative or &quot;might need&quot; features</div>
<div class="line">- [ ] All phases have clear prerequisites and deliverables</div>
</div><!-- fragment --><p>This stops the LLM from adding "nice to have" features that complicate implementation. Every feature must trace back to a concrete user story with clear acceptance criteria.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8371"></a>
The Compound Effect</h2>
<p>These constraints work together to produce specifications that are:</p>
<ul>
<li><b>Complete</b>: Checklists ensure nothing is forgotten</li>
<li><b>Unambiguous</b>: Forced clarification markers highlight uncertainties</li>
<li><b>Testable</b>: Test-first thinking baked into the process</li>
<li><b>Maintainable</b>: Proper abstraction levels and information hierarchy</li>
<li><b>Implementable</b>: Clear phases with concrete deliverables</li>
</ul>
<p>The templates transform the LLM from a creative writer into a disciplined specification engineer, channeling its capabilities toward producing consistently high-quality, executable specifications that truly drive development.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8372"></a>
The Constitutional Foundation: Enforcing Architectural Discipline</h1>
<p>At the heart of SDD lies a constitution—a set of immutable principles that govern how specifications become code. The constitution (<span class="tt">memory/constitution.md</span>) acts as the architectural DNA of the system, ensuring that every generated implementation maintains consistency, simplicity, and quality.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8373"></a>
The Nine Articles of Development</h2>
<p>The constitution defines nine articles that shape every aspect of the development process:</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8374"></a>
Article I: Library-First Principle</h3>
<p>Every feature must begin as a standalone library—no exceptions. This forces modular design from the start:</p>
<div class="fragment"><div class="line">Every feature in Specify MUST begin its existence as a standalone library.</div>
<div class="line">No feature shall be implemented directly within application code without</div>
<div class="line">first being abstracted into a reusable library component.</div>
</div><!-- fragment --><p>This principle ensures that specifications generate modular, reusable code rather than monolithic applications. When the LLM generates an implementation plan, it must structure features as libraries with clear boundaries and minimal dependencies.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8375"></a>
Article II: CLI Interface Mandate</h3>
<p>Every library must expose its functionality through a command-line interface:</p>
<div class="fragment"><div class="line">All CLI interfaces MUST:</div>
<div class="line">- Accept text as input (via stdin, arguments, or files)</div>
<div class="line">- Produce text as output (via stdout)</div>
<div class="line">- Support JSON format for structured data exchange</div>
</div><!-- fragment --><p>This enforces observability and testability. The LLM cannot hide functionality inside opaque classes—everything must be accessible and verifiable through text-based interfaces.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8376"></a>
Article III: Test-First Imperative</h3>
<p>The most transformative article—no code before tests:</p>
<div class="fragment"><div class="line">This is NON-NEGOTIABLE: All implementation MUST follow strict Test-Driven Development.</div>
<div class="line">No implementation code shall be written before:</div>
<div class="line">1. Unit tests are written</div>
<div class="line">2. Tests are validated and approved by the user</div>
<div class="line">3. Tests are confirmed to FAIL (Red phase)</div>
</div><!-- fragment --><p>This completely inverts traditional AI code generation. Instead of generating code and hoping it works, the LLM must first generate comprehensive tests that define behavior, get them approved, and only then generate implementation.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8377"></a>
Articles VII &amp; VIII: Simplicity and Anti-Abstraction</h3>
<p>These paired articles combat over-engineering:</p>
<div class="fragment"><div class="line">Section 7.3: Minimal Project Structure</div>
<div class="line">- Maximum 3 projects for initial implementation</div>
<div class="line">- Additional projects require documented justification</div>
<div class="line"> </div>
<div class="line">Section 8.1: Framework Trust</div>
<div class="line">- Use framework features directly rather than wrapping them</div>
</div><!-- fragment --><p>When an LLM might naturally create elaborate abstractions, these articles force it to justify every layer of complexity. The implementation plan template's "Phase -1 Gates" directly enforce these principles.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md8378"></a>
Article IX: Integration-First Testing</h3>
<p>Prioritizes real-world testing over isolated unit tests:</p>
<div class="fragment"><div class="line">Tests MUST use realistic environments:</div>
<div class="line">- Prefer real databases over mocks</div>
<div class="line">- Use actual service instances over stubs</div>
<div class="line">- Contract tests mandatory before implementation</div>
</div><!-- fragment --><p>This ensures generated code works in practice, not just in theory.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8379"></a>
Constitutional Enforcement Through Templates</h2>
<p>The implementation plan template operationalizes these articles through concrete checkpoints:</p>
<div class="fragment"><div class="line">### Phase -1: Pre-Implementation Gates</div>
<div class="line">#### Simplicity Gate (Article VII)</div>
<div class="line">- [ ] Using ≤3 projects?</div>
<div class="line">- [ ] No future-proofing?</div>
<div class="line"> </div>
<div class="line">#### Anti-Abstraction Gate (Article VIII)</div>
<div class="line">- [ ] Using framework directly?</div>
<div class="line">- [ ] Single model representation?</div>
<div class="line"> </div>
<div class="line">#### Integration-First Gate (Article IX)</div>
<div class="line">- [ ] Contracts defined?</div>
<div class="line">- [ ] Contract tests written?</div>
</div><!-- fragment --><p>These gates act as compile-time checks for architectural principles. The LLM cannot proceed without either passing the gates or documenting justified exceptions in the "Complexity Tracking" section.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8380"></a>
The Power of Immutable Principles</h2>
<p>The constitution's power lies in its immutability. While implementation details can evolve, the core principles remain constant. This provides:</p>
<ol type="1">
<li><b>Consistency Across Time</b>: Code generated today follows the same principles as code generated next year</li>
<li><b>Consistency Across LLMs</b>: Different AI models produce architecturally compatible code</li>
<li><b>Architectural Integrity</b>: Every feature reinforces rather than undermines the system design</li>
<li><b>Quality Guarantees</b>: Test-first, library-first, and simplicity principles ensure maintainable code</li>
</ol>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8381"></a>
Constitutional Evolution</h2>
<p>While principles are immutable, their application can evolve:</p>
<div class="fragment"><div class="line">Section 4.2: Amendment Process</div>
<div class="line">Modifications to this constitution require:</div>
<div class="line">- Explicit documentation of the rationale for change</div>
<div class="line">- Review and approval by project maintainers</div>
<div class="line">- Backwards compatibility assessment</div>
</div><!-- fragment --><p>This allows the methodology to learn and improve while maintaining stability. The constitution shows its own evolution with dated amendments, demonstrating how principles can be refined based on real-world experience.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md8382"></a>
Beyond Rules: A Development Philosophy</h2>
<p>The constitution isn't just a rulebook—it's a philosophy that shapes how LLMs think about code generation:</p>
<ul>
<li><b>Observability Over Opacity</b>: Everything must be inspectable through CLI interfaces</li>
<li><b>Simplicity Over Cleverness</b>: Start simple, add complexity only when proven necessary</li>
<li><b>Integration Over Isolation</b>: Test in real environments, not artificial ones</li>
<li><b>Modularity Over Monoliths</b>: Every feature is a library with clear boundaries</li>
</ul>
<p>By embedding these principles into the specification and planning process, SDD ensures that generated code isn't just functional—it's maintainable, testable, and architecturally sound. The constitution transforms AI from a code generator into an architectural partner that respects and reinforces system design principles.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md8383"></a>
The Transformation</h1>
<p>This isn't about replacing developers or automating creativity. It's about amplifying human capability by automating mechanical translation. It's about creating a tight feedback loop where specifications, research, and code evolve together, each iteration bringing deeper understanding and better alignment between intent and implementation.</p>
<p>Software development needs better tools for maintaining alignment between intent and implementation. SDD provides the methodology for achieving this alignment through executable specifications that generate code rather than merely guiding it. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for ACP - Autonomous Command Protocol by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
