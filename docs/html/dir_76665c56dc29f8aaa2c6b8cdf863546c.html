<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACP - Autonomous Command Protocol: /Users/paulzanna/Github/Eunice/frontend/node_modules/expect-type Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACP - Autonomous Command Protocol<span id="projectnumber">&#160;v0.3.0</span>
   </div>
   <div id="projectbrief">Portable C99 framing library with COBS, CRC16, and HMAC-SHA256 authentication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_76665c56dc29f8aaa2c6b8cdf863546c.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">expect-type Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4543"></a>
expect-type</h1>
<p><a href="https://github.com/mmkal/expect-type/actions/workflows/ci.yml"><img src="https://github.com/mmkal/expect-type/actions/workflows/ci.yml/badge.svg" alt="CI" style="pointer-events: none;" class="inline"/></a> <img src="https://img.shields.io/npm/dt/expect-type" alt="npm" class="inline"/> <a href="https://x.com/mmkalmmkal"><img src="https://img.shields.io/twitter/follow/mmkal" alt="X (formerly Twitter) Follow" class="inline"/></a></p>
<p>Compile-time tests for types. Useful to make sure types don't regress into being overly permissive as changes go in over time.</p>
<p>Similar to <span class="tt">expect</span>, but with type-awareness. Gives you access to several type-matchers that let you make assertions about the form of a reference or generic type parameter.</p>
<div class="fragment"><div class="line">import {expectTypeOf} from &#39;expect-type&#39;</div>
<div class="line">import {foo, bar} from &#39;../foo&#39;</div>
<div class="line"> </div>
<div class="line">// make sure `foo` has type {a: number}</div>
<div class="line">expectTypeOf(foo).toEqualTypeOf&lt;{a: number}&gt;()</div>
<div class="line"> </div>
<div class="line">// make sure `bar` is a function taking a string:</div>
<div class="line">expectTypeOf(bar).parameter(0).toBeString()</div>
<div class="line">expectTypeOf(bar).returns.not.toBeAny()</div>
</div><!-- fragment --><p>It can be used in your existing test files (and is actually <a href="https://vitest.dev/guide/testing-types">built in to vitest</a>). Or it can be used in any other type-checked file you'd like - it's built into existing tooling with no dependencies. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time - they'll appear in your IDE and when you run <span class="tt">tsc</span>.</p>
<p>See below for lots more examples.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4544"></a>
Contents</h1>
<ul>
<li>Contents</li>
<li>Installation and usage</li>
<li>Documentation<ul>
<li><a class="el" href="md__2_users_2paulzanna_2_github_2_eunice_2frontend_2node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g.html#features">Features</a></li>
<li>Why is my assertion failing?</li>
<li>Why is `.toMatchTypeOf` deprecated?</li>
<li>Internal type helpers</li>
<li>Error messages<ul>
<li>Concrete &quot;expected&quot; objects vs type arguments</li>
</ul>
</li>
<li>Overloaded functions</li>
<li>Within test frameworks</li>
<li>Vitest<ul>
<li>Jest &amp; `eslint-plugin-jest`</li>
</ul>
</li>
<li>Limitations</li>
</ul>
</li>
<li>Similar projects<ul>
<li>Comparison</li>
</ul>
</li>
<li>TypeScript backwards-compatibility</li>
<li><a class="el" href="md__2_users_2paulzanna_2_github_2_eunice_2frontend_2node__modules_2chai_2_c_o_n_t_r_i_b_u_t_i_n_g.html#contributing">Contributing</a><ul>
<li>Documentation of limitations through tests</li>
</ul>
</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4545"></a>
Installation and usage</h1>
<div class="fragment"><div class="line">npm install expect-type --save-dev</div>
</div><!-- fragment --><div class="fragment"><div class="line">import {expectTypeOf} from &#39;expect-type&#39;</div>
</div><!-- fragment --><h1 class="doxsection"><a class="anchor" id="autotoc_md4546"></a>
Documentation</h1>
<p>The <span class="tt">expectTypeOf</span> method takes a single argument or a generic type parameter. Neither it nor the functions chained off its return value have any meaningful runtime behaviour. The assertions you write will be <em>compile-time</em> errors if they don't hold true.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4547"></a>
Features</h2>
<p>Check an object's type with <span class="tt">.toEqualTypeOf</span>:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span> can check that two concrete objects have equivalent types (note: when these assertions <em>fail</em>, the error messages can be less informative vs the generic type argument syntax above - see error messages docs):</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: 1})</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span> succeeds for objects with different values, but the same type:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: 2})</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span> fails on excess properties:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1, b: 1}).toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p>To allow for extra properties on an object type, use <span class="tt">.toMatchObjectType</span>. This is a strict check, but only on the subset of keys that are in the expected type:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1, b: 1}).toMatchObjectType&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p><span class="tt">.toMatchObjectType</span> can check partial matches on deeply nested objects:</p>
<div class="fragment"><div class="line">const user = {</div>
<div class="line">  email: &#39;a@b.com&#39;,</div>
<div class="line">  name: &#39;John Doe&#39;,</div>
<div class="line">  address: {street: &#39;123 2nd St&#39;, city: &#39;New York&#39;, zip: &#39;10001&#39;, state: &#39;NY&#39;, country: &#39;USA&#39;},</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(user).toMatchObjectType&lt;{name: string; address: {city: string}}&gt;()</div>
</div><!-- fragment --><p>To check that a type extends another type, use <span class="tt">.toExtend</span>:</p>
<div class="fragment"><div class="line">expectTypeOf(&#39;some string&#39;).toExtend&lt;string | boolean&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toExtend&lt;{b: number}&gt;()</div>
</div><!-- fragment --><p><span class="tt">.toExtend</span> can be used with object types, but <span class="tt">.toMatchObjectType</span> is usually a better choice when dealing with objects, since it's stricter:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1, b: 2}).toExtend&lt;{a: number}&gt;() // avoid this</div>
<div class="line">expectTypeOf({a: 1, b: 2}).toMatchObjectType&lt;{a: number}&gt;() // prefer this</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span>, <span class="tt">.toMatchObjectType</span>, and <span class="tt">.toExtend</span> all fail on missing properties:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: number; b: number}&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toMatchObjectType&lt;{a: number; b: number}&gt;()</div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf({a: 1}).toExtend&lt;{a: number; b: number}&gt;()</div>
</div><!-- fragment --><p>Another example of the difference between <span class="tt">.toExtend</span>, <span class="tt">.toMatchObjectType</span>, and <span class="tt">.toEqualTypeOf</span>. <span class="tt">.toExtend</span> can be used for "is-a" relationships:</p>
<div class="fragment"><div class="line">type Fruit = {type: &#39;Fruit&#39;; edible: boolean}</div>
<div class="line">type Apple = {type: &#39;Fruit&#39;; name: &#39;Apple&#39;; edible: true}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Apple&gt;().toExtend&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - the `editable` property isn&#39;t an exact match. In `Apple`, it&#39;s `true`, which extends `boolean`, but they&#39;re not identical.</div>
<div class="line">expectTypeOf&lt;Apple&gt;().toMatchObjectType&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - Apple is not an identical type to Fruit, it&#39;s a subtype</div>
<div class="line">expectTypeOf&lt;Apple&gt;().toEqualTypeOf&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error - Apple is a Fruit, but not vice versa</div>
<div class="line">expectTypeOf&lt;Fruit&gt;().toExtend&lt;Apple&gt;()</div>
</div><!-- fragment --><p>Assertions can be inverted with <span class="tt">.not</span>:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).not.toExtend&lt;{b: 1}&gt;()</div>
<div class="line">expectTypeOf({a: 1}).not.toMatchObjectType&lt;{b: 1}&gt;()</div>
</div><!-- fragment --><p><span class="tt">.not</span> can be easier than relying on <span class="tt">// @ts-expect-error</span>:</p>
<div class="fragment"><div class="line">type Fruit = {type: &#39;Fruit&#39;; edible: boolean}</div>
<div class="line">type Apple = {type: &#39;Fruit&#39;; name: &#39;Apple&#39;; edible: true}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Apple&gt;().toExtend&lt;Fruit&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Fruit&gt;().not.toExtend&lt;Apple&gt;()</div>
<div class="line">expectTypeOf&lt;Apple&gt;().not.toEqualTypeOf&lt;Fruit&gt;()</div>
</div><!-- fragment --><p>Catch any/unknown/never types:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;unknown&gt;().toBeUnknown()</div>
<div class="line">expectTypeOf&lt;any&gt;().toBeAny()</div>
<div class="line">expectTypeOf&lt;never&gt;().toBeNever()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf&lt;never&gt;().toBeNumber()</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span> distinguishes between deeply-nested <span class="tt">any</span> and <span class="tt">unknown</span> properties:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{deeply: {nested: any}}&gt;().not.toEqualTypeOf&lt;{deeply: {nested: unknown}}&gt;()</div>
</div><!-- fragment --><p>You can test for basic JavaScript types:</p>
<div class="fragment"><div class="line">expectTypeOf(() =&gt; 1).toBeFunction()</div>
<div class="line">expectTypeOf({}).toBeObject()</div>
<div class="line">expectTypeOf([]).toBeArray()</div>
<div class="line">expectTypeOf(&#39;&#39;).toBeString()</div>
<div class="line">expectTypeOf(1).toBeNumber()</div>
<div class="line">expectTypeOf(true).toBeBoolean()</div>
<div class="line">expectTypeOf(() =&gt; {}).returns.toBeVoid()</div>
<div class="line">expectTypeOf(Promise.resolve(123)).resolves.toBeNumber()</div>
<div class="line">expectTypeOf(Symbol(1)).toBeSymbol()</div>
<div class="line">expectTypeOf(1n).toBeBigInt()</div>
</div><!-- fragment --><p><span class="tt">.toBe...</span> methods allow for types that extend the expected type:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;number&gt;().toBeNumber()</div>
<div class="line">expectTypeOf&lt;1&gt;().toBeNumber()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;any[]&gt;().toBeArray()</div>
<div class="line">expectTypeOf&lt;number[]&gt;().toBeArray()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;string&gt;().toBeString()</div>
<div class="line">expectTypeOf&lt;&#39;foo&#39;&gt;().toBeString()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;boolean&gt;().toBeBoolean()</div>
<div class="line">expectTypeOf&lt;true&gt;().toBeBoolean()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;bigint&gt;().toBeBigInt()</div>
<div class="line">expectTypeOf&lt;0n&gt;().toBeBigInt()</div>
</div><!-- fragment --><p><span class="tt">.toBe...</span> methods protect against <span class="tt">any</span>:</p>
<div class="fragment"><div class="line">const goodIntParser = (s: string) =&gt; Number.parseInt(s, 10)</div>
<div class="line">const badIntParser = (s: string) =&gt; JSON.parse(s) // uh-oh - works at runtime if the input is a number, but return &#39;any&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(goodIntParser).returns.toBeNumber()</div>
<div class="line">// @ts-expect-error - if you write a test like this, `.toBeNumber()` will let you know your implementation returns `any`.</div>
<div class="line">expectTypeOf(badIntParser).returns.toBeNumber()</div>
</div><!-- fragment --><p>Nullable types:</p>
<div class="fragment"><div class="line">expectTypeOf(undefined).toBeUndefined()</div>
<div class="line">expectTypeOf(undefined).toBeNullable()</div>
<div class="line">expectTypeOf(undefined).not.toBeNull()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(null).toBeNull()</div>
<div class="line">expectTypeOf(null).toBeNullable()</div>
<div class="line">expectTypeOf(null).not.toBeUndefined()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;1 | undefined&gt;().toBeNullable()</div>
<div class="line">expectTypeOf&lt;1 | null&gt;().toBeNullable()</div>
<div class="line">expectTypeOf&lt;1 | undefined | null&gt;().toBeNullable()</div>
</div><!-- fragment --><p>More <span class="tt">.not</span> examples:</p>
<div class="fragment"><div class="line">expectTypeOf(1).not.toBeUnknown()</div>
<div class="line">expectTypeOf(1).not.toBeAny()</div>
<div class="line">expectTypeOf(1).not.toBeNever()</div>
<div class="line">expectTypeOf(1).not.toBeNull()</div>
<div class="line">expectTypeOf(1).not.toBeUndefined()</div>
<div class="line">expectTypeOf(1).not.toBeNullable()</div>
<div class="line">expectTypeOf(1).not.toBeBigInt()</div>
</div><!-- fragment --><p>Detect assignability of unioned types:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;number&gt;().toExtend&lt;string | number&gt;()</div>
<div class="line">expectTypeOf&lt;string | number&gt;().not.toExtend&lt;number&gt;()</div>
</div><!-- fragment --><p>Use <span class="tt">.extract</span> and <span class="tt">.exclude</span> to narrow down complex union types:</p>
<div class="fragment"><div class="line">type ResponsiveProp&lt;T&gt; = T | T[] | {xs?: T; sm?: T; md?: T}</div>
<div class="line">const getResponsiveProp = &lt;T&gt;(_props: T): ResponsiveProp&lt;T&gt; =&gt; ({})</div>
<div class="line">type CSSProperties = {margin?: string; padding?: string}</div>
<div class="line"> </div>
<div class="line">const cssProperties: CSSProperties = {margin: &#39;1px&#39;, padding: &#39;2px&#39;}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .exclude&lt;unknown[]&gt;()</div>
<div class="line">  .exclude&lt;{xs?: unknown}&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;CSSProperties&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .extract&lt;unknown[]&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;CSSProperties[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(getResponsiveProp(cssProperties))</div>
<div class="line">  .extract&lt;{xs?: any}&gt;()</div>
<div class="line">  .toEqualTypeOf&lt;{xs?: CSSProperties; sm?: CSSProperties; md?: CSSProperties}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;ResponsiveProp&lt;number&gt;&gt;().exclude&lt;number | number[]&gt;().toHaveProperty(&#39;sm&#39;)</div>
<div class="line">expectTypeOf&lt;ResponsiveProp&lt;number&gt;&gt;().exclude&lt;number | number[]&gt;().not.toHaveProperty(&#39;xxl&#39;)</div>
</div><!-- fragment --><p><span class="tt">.extract</span> and <span class="tt">.exclude</span> return never if no types remain after exclusion:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line">type Customer = Person &amp; {customerId: string}</div>
<div class="line">type Employee = Person &amp; {employeeId: string}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Customer | Employee&gt;().extract&lt;{foo: string}&gt;().toBeNever()</div>
<div class="line">expectTypeOf&lt;Customer | Employee&gt;().exclude&lt;{name: string}&gt;().toBeNever()</div>
</div><!-- fragment --><p>Use <span class="tt">.pick</span> to pick a set of properties from an object:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Person&gt;().pick&lt;&#39;name&#39;&gt;().toEqualTypeOf&lt;{name: string}&gt;()</div>
</div><!-- fragment --><p>Use <span class="tt">.omit</span> to remove a set of properties from an object:</p>
<div class="fragment"><div class="line">type Person = {name: string; age: number}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Person&gt;().omit&lt;&#39;name&#39;&gt;().toEqualTypeOf&lt;{age: number}&gt;()</div>
</div><!-- fragment --><p>Make assertions about object properties:</p>
<div class="fragment"><div class="line">const obj = {a: 1, b: &#39;&#39;}</div>
<div class="line"> </div>
<div class="line">// check that properties exist (or don&#39;t) with `.toHaveProperty`</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;)</div>
<div class="line">expectTypeOf(obj).not.toHaveProperty(&#39;c&#39;)</div>
<div class="line"> </div>
<div class="line">// check types of properties</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;).toBeNumber()</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;b&#39;).toBeString()</div>
<div class="line">expectTypeOf(obj).toHaveProperty(&#39;a&#39;).not.toBeString()</div>
</div><!-- fragment --><p><span class="tt">.toEqualTypeOf</span> can be used to distinguish between functions:</p>
<div class="fragment"><div class="line">type NoParam = () =&gt; void</div>
<div class="line">type HasParam = (s: string) =&gt; void</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;NoParam&gt;().not.toEqualTypeOf&lt;HasParam&gt;()</div>
</div><!-- fragment --><p>But often it's preferable to use <span class="tt">.parameters</span> or <span class="tt">.returns</span> for more specific function assertions:</p>
<div class="fragment"><div class="line">type NoParam = () =&gt; void</div>
<div class="line">type HasParam = (s: string) =&gt; void</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;NoParam&gt;().parameters.toEqualTypeOf&lt;[]&gt;()</div>
<div class="line">expectTypeOf&lt;NoParam&gt;().returns.toBeVoid()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;HasParam&gt;().parameters.toEqualTypeOf&lt;[string]&gt;()</div>
<div class="line">expectTypeOf&lt;HasParam&gt;().returns.toBeVoid()</div>
</div><!-- fragment --><p>Up to ten overloads will produce union types for <span class="tt">.parameters</span> and <span class="tt">.returns</span>:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.not.toEqualTypeOf&lt;[number]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.toEqualTypeOf&lt;[number] | [bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().returns.toEqualTypeOf&lt;number[] | bigint[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameter(0).toEqualTypeOf&lt;number | bigint&gt;()</div>
</div><!-- fragment --><p>Note that these aren't exactly like TypeScript's built-in Parameters&lt;...&gt; and ReturnType&lt;...&gt;:</p>
<p>The TypeScript builtins simply choose a single overload (see the Overloaded functions section for more information)</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// overload using `number` is ignored!</div>
<div class="line">expectTypeOf&lt;Parameters&lt;Factorize&gt;&gt;().toEqualTypeOf&lt;[bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;ReturnType&lt;Factorize&gt;&gt;().toEqualTypeOf&lt;bigint[]&gt;()</div>
</div><!-- fragment --><p>More examples of ways to work with functions - parameters using <span class="tt">.parameter(n)</span> or <span class="tt">.parameters</span>, and return values using <span class="tt">.returns</span>:</p>
<div class="fragment"><div class="line">const f = (a: number) =&gt; [a, a]</div>
<div class="line"> </div>
<div class="line">expectTypeOf(f).toBeFunction()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(f).toBeCallableWith(1)</div>
<div class="line">expectTypeOf(f).not.toBeAny()</div>
<div class="line">expectTypeOf(f).returns.not.toBeAny()</div>
<div class="line">expectTypeOf(f).returns.toEqualTypeOf([1, 2])</div>
<div class="line">expectTypeOf(f).returns.toEqualTypeOf([1, 2, 3])</div>
<div class="line">expectTypeOf(f).parameter(0).not.toEqualTypeOf(&#39;1&#39;)</div>
<div class="line">expectTypeOf(f).parameter(0).toEqualTypeOf(1)</div>
<div class="line">expectTypeOf(1).parameter(0).toBeNever()</div>
<div class="line"> </div>
<div class="line">const twoArgFunc = (a: number, b: string) =&gt; ({a, b})</div>
<div class="line"> </div>
<div class="line">expectTypeOf(twoArgFunc).parameters.toEqualTypeOf&lt;[number, string]&gt;()</div>
</div><!-- fragment --><p><span class="tt">.toBeCallableWith</span> allows for overloads. You can also use it to narrow down the return type for given input parameters.:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6)</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6n)</div>
</div><!-- fragment --><p><span class="tt">.toBeCallableWith</span> returns a type that can be used to narrow down the return type for given input parameters.:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6).returns.toEqualTypeOf&lt;number[]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().toBeCallableWith(6n).returns.toEqualTypeOf&lt;bigint[]&gt;()</div>
</div><!-- fragment --><p><span class="tt">.toBeCallableWith</span> can be used to narrow down the parameters of a function:</p>
<div class="fragment"><div class="line">type Delete = {</div>
<div class="line">  (path: string): void</div>
<div class="line">  (paths: string[], options?: {force: boolean}): void</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameters.toEqualTypeOf&lt;[string]&gt;()</div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;], {force: true})</div>
<div class="line">  .parameters.toEqualTypeOf&lt;[string[], {force: boolean}?]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameter(0).toBeString()</div>
<div class="line">expectTypeOf&lt;Delete&gt;().toBeCallableWith(&#39;abc&#39;).parameter(1).toBeUndefined()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;])</div>
<div class="line">  .parameter(0)</div>
<div class="line">  .toEqualTypeOf&lt;string[]&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Delete&gt;()</div>
<div class="line">  .toBeCallableWith([&#39;abc&#39;, &#39;def&#39;, &#39;ghi&#39;])</div>
<div class="line">  .parameter(1)</div>
<div class="line">  .toEqualTypeOf&lt;{force: boolean} | undefined&gt;()</div>
</div><!-- fragment --><p>You can't use <span class="tt">.toBeCallableWith</span> with <span class="tt">.not</span> - you need to use ts-expect-error::</p>
<div class="fragment"><div class="line">const f = (a: number) =&gt; [a, a]</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf(f).toBeCallableWith(&#39;foo&#39;)</div>
</div><!-- fragment --><p>Use <span class="tt">.map</span> to transform types:</p>
<p>This can be useful for generic functions or complex types which you can't access via <span class="tt">.toBeCallableWith</span>, <span class="tt">.toHaveProperty</span> etc. The callback function isn't called at runtime, which can make this a useful way to get complex inferred types without worrying about running code.</p>
<div class="fragment"><div class="line">const capitalize = &lt;S extends string&gt;(input: S) =&gt;</div>
<div class="line">  (input.slice(0, 1).toUpperCase() + input.slice(1)) as Capitalize&lt;S&gt;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(capitalize)</div>
<div class="line">  .map(fn =&gt; fn(&#39;hello world&#39;))</div>
<div class="line">  .toEqualTypeOf&lt;&#39;Hello world&#39;&gt;()</div>
</div><!-- fragment --><p>You can also check type guards &amp; type assertions:</p>
<div class="fragment"><div class="line">const assertNumber = (v: any): asserts v is number =&gt; {</div>
<div class="line">  if (typeof v !== &#39;number&#39;) {</div>
<div class="line">    throw new TypeError(&#39;Nope !&#39;)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(assertNumber).asserts.toBeNumber()</div>
<div class="line"> </div>
<div class="line">const isString = (v: any): v is string =&gt; typeof v === &#39;string&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(isString).guards.toBeString()</div>
<div class="line"> </div>
<div class="line">const isBigInt = (value: any): value is bigint =&gt; typeof value === &#39;bigint&#39;</div>
<div class="line"> </div>
<div class="line">expectTypeOf(isBigInt).guards.toBeBigInt()</div>
</div><!-- fragment --><p>Assert on constructor parameters:</p>
<div class="fragment"><div class="line">expectTypeOf(Date).toBeConstructibleWith(&#39;1970&#39;)</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith(0)</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith(new Date())</div>
<div class="line">expectTypeOf(Date).toBeConstructibleWith()</div>
<div class="line"> </div>
<div class="line">expectTypeOf(Date).constructorParameters.toEqualTypeOf&lt;</div>
<div class="line">  | []</div>
<div class="line">  | [value: string | number]</div>
<div class="line">  | [value: string | number | Date]</div>
<div class="line">  | [</div>
<div class="line">      year: number,</div>
<div class="line">      monthIndex: number,</div>
<div class="line">      date?: number | undefined,</div>
<div class="line">      hours?: number | undefined,</div>
<div class="line">      minutes?: number | undefined,</div>
<div class="line">      seconds?: number | undefined,</div>
<div class="line">      ms?: number | undefined,</div>
<div class="line">    ]</div>
<div class="line">&gt;()</div>
</div><!-- fragment --><p>Constructor overloads:</p>
<div class="fragment"><div class="line">class DBConnection {</div>
<div class="line">  constructor()</div>
<div class="line">  constructor(connectionString: string)</div>
<div class="line">  constructor(options: {host: string; port: number})</div>
<div class="line">  constructor(..._: unknown[]) {}</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith()</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith(&#39;localhost&#39;)</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith({host: &#39;localhost&#39;, port: 1234})</div>
<div class="line">// @ts-expect-error - as when calling `new DBConnection(...)` you can&#39;t actually use the `(...args: unknown[])` overlaod, it&#39;s purely for the implementation.</div>
<div class="line">expectTypeOf(DBConnection).toBeConstructibleWith(1, 2)</div>
</div><!-- fragment --><p>Check function <span class="tt">this</span> parameters:</p>
<div class="fragment"><div class="line">function greet(this: {name: string}, message: string) {</div>
<div class="line">  return `Hello ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(greet).thisParameter.toEqualTypeOf&lt;{name: string}&gt;()</div>
</div><!-- fragment --><p>Distinguish between functions with different <span class="tt">this</span> parameters:</p>
<div class="fragment"><div class="line">function greetFormal(this: {title: string; name: string}, message: string) {</div>
<div class="line">  return `Dear ${this.title} ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">function greetCasual(this: {name: string}, message: string) {</div>
<div class="line">  return `Hi ${this.name}, here&#39;s your message: ${message}`</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(greetFormal).not.toEqualTypeOf(greetCasual)</div>
</div><!-- fragment --><p>Class instance types:</p>
<div class="fragment"><div class="line">expectTypeOf(Date).instance.toHaveProperty(&#39;toISOString&#39;)</div>
</div><!-- fragment --><p>Promise resolution types can be checked with <span class="tt">.resolves</span>:</p>
<div class="fragment"><div class="line">const asyncFunc = async () =&gt; 123</div>
<div class="line"> </div>
<div class="line">expectTypeOf(asyncFunc).returns.resolves.toBeNumber()</div>
</div><!-- fragment --><p>Array items can be checked with <span class="tt">.items</span>:</p>
<div class="fragment"><div class="line">expectTypeOf([1, 2, 3]).items.toBeNumber()</div>
<div class="line">expectTypeOf([1, 2, 3]).items.not.toBeString()</div>
</div><!-- fragment --><p>You can also compare arrays directly:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;any[]&gt;().not.toEqualTypeOf&lt;number[]&gt;()</div>
</div><!-- fragment --><p>Check that functions never return:</p>
<div class="fragment"><div class="line">const thrower = () =&gt; {</div>
<div class="line">  throw new Error(&#39;oh no&#39;)</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf(thrower).returns.toBeNever()</div>
</div><!-- fragment --><p>Generics can be used rather than references:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{a: string}&gt;().not.toEqualTypeOf&lt;{a: number}&gt;()</div>
</div><!-- fragment --><p>Distinguish between missing/null/optional properties:</p>
<div class="fragment"><div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{a: number}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number}&gt;().not.toEqualTypeOf&lt;{a: number | undefined}&gt;()</div>
<div class="line">expectTypeOf&lt;{a?: number | null}&gt;().not.toEqualTypeOf&lt;{a: number | null}&gt;()</div>
<div class="line">expectTypeOf&lt;{a: {b?: number}}&gt;().not.toEqualTypeOf&lt;{a: {}}&gt;()</div>
</div><!-- fragment --><p>Detect the difference between regular and <span class="tt">readonly</span> properties:</p>
<div class="fragment"><div class="line">type A1 = {readonly a: string; b: string}</div>
<div class="line">type E1 = {a: string; b: string}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;A1&gt;().toExtend&lt;E1&gt;()</div>
<div class="line">expectTypeOf&lt;A1&gt;().not.toEqualTypeOf&lt;E1&gt;()</div>
<div class="line"> </div>
<div class="line">type A2 = {a: string; b: {readonly c: string}}</div>
<div class="line">type E2 = {a: string; b: {c: string}}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;A2&gt;().toExtend&lt;E2&gt;()</div>
<div class="line">expectTypeOf&lt;A2&gt;().not.toEqualTypeOf&lt;E2&gt;()</div>
</div><!-- fragment --><p>Distinguish between classes with different constructors:</p>
<div class="fragment"><div class="line">class A {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(a: 1) {</div>
<div class="line">    this.value = a</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line">class B {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(b: 2) {</div>
<div class="line">    this.value = b</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;typeof A&gt;().not.toEqualTypeOf&lt;typeof B&gt;()</div>
<div class="line"> </div>
<div class="line">class C {</div>
<div class="line">  value: number</div>
<div class="line">  constructor(c: 1) {</div>
<div class="line">    this.value = c</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;typeof A&gt;().toEqualTypeOf&lt;typeof C&gt;()</div>
</div><!-- fragment --><p>Known limitation: Intersection types can cause issues with <span class="tt">toEqualTypeOf</span>:</p>
<div class="fragment"><div class="line">// @ts-expect-error the following line doesn&#39;t compile, even though the types are arguably the same.</div>
<div class="line">// See https://github.com/mmkal/expect-type/pull/21</div>
<div class="line">expectTypeOf&lt;{a: 1} &amp; {b: 2}&gt;().toEqualTypeOf&lt;{a: 1; b: 2}&gt;()</div>
</div><!-- fragment --><p>To workaround for simple cases, you can use a mapped type:</p>
<div class="fragment"><div class="line">type Simplify&lt;T&gt; = {[K in keyof T]: T[K]}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Simplify&lt;{a: 1} &amp; {b: 2}&gt;&gt;().toEqualTypeOf&lt;{a: 1; b: 2}&gt;()</div>
</div><!-- fragment --><p>But this won't work if the nesting is deeper in the type. For these situations, you can use the <span class="tt">.branded</span> helper. Note that this comes at a performance cost, and can cause the compiler to 'give up' if used with excessively deep types, so use sparingly. This helper is under <span class="tt">.branded</span> because it deeply transforms the Actual and Expected types into a pseudo-AST:</p>
<div class="fragment"><div class="line">// @ts-expect-error</div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().branded.toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
</div><!-- fragment --><p>Be careful with <span class="tt">.branded</span> for very deep or complex types, though. If possible you should find a way to simplify your test to avoid needing to use it:</p>
<div class="fragment"><div class="line">// This *should* result in an error, but the &quot;branding&quot; mechanism produces too large a type and TypeScript just gives up! https://github.com/microsoft/TypeScript/issues/50670</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 1&gt;().branded.toEqualTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 2&gt;()</div>
<div class="line"> </div>
<div class="line">// @ts-expect-error the non-branded implementation catches the error as expected.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 1&gt;().toEqualTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; 2&gt;()</div>
</div><!-- fragment --><p>So, if you have an extremely deep type that ALSO has an intersection in it, you're out of luck and this library won't be able to test your type properly:</p>
<div class="fragment"><div class="line">// @ts-expect-error this fails, but it should succeed.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; {a: 1} &amp; {b: 2}&gt;().toEqualTypeOf&lt;</div>
<div class="line">  () =&gt; () =&gt; () =&gt; () =&gt; {a: 1; b: 2}</div>
<div class="line">&gt;()</div>
<div class="line"> </div>
<div class="line">// this succeeds, but it should fail.</div>
<div class="line">expectTypeOf&lt;() =&gt; () =&gt; () =&gt; () =&gt; {a: 1} &amp; {b: 2}&gt;().branded.toEqualTypeOf&lt;</div>
<div class="line">  () =&gt; () =&gt; () =&gt; () =&gt; {a: 1; c: 2}</div>
<div class="line">&gt;()</div>
</div><!-- fragment --><p>Another limitation: passing <span class="tt">this</span> references to <span class="tt">expectTypeOf</span> results in errors.:</p>
<div class="fragment"><div class="line">class B {</div>
<div class="line">  b = &#39;b&#39;</div>
<div class="line"> </div>
<div class="line">  foo() {</div>
<div class="line">    // @ts-expect-error</div>
<div class="line">    expectTypeOf(this).toEqualTypeOf(this)</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">// Instead of the above, try something like this:</div>
<div class="line">expectTypeOf(B).instance.toEqualTypeOf&lt;{b: string; foo: () =&gt; void}&gt;()</div>
</div><!-- fragment --><p>Overloads limitation for TypeScript &lt;5.3: Due to a <a href="https://github.com/microsoft/TypeScript/issues/28867">TypeScript bug fixed in 5.3</a>, overloaded functions which include an overload resembling <span class="tt">(...args: unknown[]) =&gt; unknown</span> will exclude <span class="tt">unknown[]</span> from <span class="tt">.parameters</span> and exclude <span class="tt">unknown</span> from <span class="tt">.returns</span>:</p>
<div class="fragment"><div class="line">type Factorize = {</div>
<div class="line">  (...args: unknown[]): unknown</div>
<div class="line">  (input: number): number[]</div>
<div class="line">  (input: bigint): bigint[]</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;Factorize&gt;().parameters.toEqualTypeOf&lt;[number] | [bigint]&gt;()</div>
<div class="line">expectTypeOf&lt;Factorize&gt;().returns.toEqualTypeOf&lt;number[] | bigint[]&gt;()</div>
</div><!-- fragment --><p>This overload, however, allows any input and returns an unknown output anyway, so it's not very useful. If you are worried about this for some reason, you'll have to update TypeScript to 5.3+.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4548"></a>
Why is my assertion failing?</h2>
<p>For complex types, an assertion might fail when it should if the <span class="tt">Actual</span> type contains a deeply-nested intersection type but the <span class="tt">Expected</span> doesn't. In these cases you can use <span class="tt">.branded</span> as described above:</p>
<div class="fragment"><div class="line">// @ts-expect-error this unfortunately fails - a TypeScript limitation prevents making this pass without a big perf hit</div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
<div class="line"> </div>
<div class="line">expectTypeOf&lt;{a: {b: 1} &amp; {c: 1}}&gt;().branded.toEqualTypeOf&lt;{a: {b: 1; c: 1}}&gt;()</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md4549"></a>
Why is <span class="tt">.toMatchTypeOf</span> deprecated?</h2>
<p>The <span class="tt">.toMatchTypeOf</span> method is deprecated in favour of <span class="tt">.toMatchObjectType</span> (when strictly checking against an object type with a subset of keys), or <span class="tt">.toExtend</span> (when checking for "is-a" relationships). There are no foreseeable plans to remove <span class="tt">.toMatchTypeOf</span>, but there's no reason to continue using it - <span class="tt">.toMatchObjectType</span> is stricter, and <span class="tt">.toExtend</span> is identical.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4550"></a>
Internal type helpers</h2>
<p>🚧 This library also exports some helper types for performing boolean operations on types, checking extension/equality in various ways, branding types, and checking for various special types like <span class="tt">never</span>, <span class="tt">any</span>, <span class="tt">unknown</span>. Use at your own risk! Nothing is stopping you from using these beyond this warning:</p>
<p>&gt;All internal types that are not documented here are <em>not</em> part of the supported API surface, and may be renamed, modified, or removed, without warning or documentation in release notes.</p>
<p>For a dedicated internal type library, feel free to look at the <a href="./src/index.ts">source code</a> for inspiration - or better, use a library like <a href="https://npmjs.com/package/type-fest">type-fest</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4551"></a>
Error messages</h2>
<p>When types don't match, <span class="tt">.toEqualTypeOf</span> and <span class="tt">.toMatchTypeOf</span> use a special helper type to produce error messages that are as actionable as possible. But there's a bit of a nuance to understanding them. Since the assertions are written "fluently", the failure should be on the "expected" type, not the "actual" type (<span class="tt">expect&lt;Actual&gt;().toEqualTypeOf&lt;Expected&gt;()</span>). This means that type errors can be a little confusing - so this library produces a <span class="tt">MismatchInfo</span> type to try to make explicit what the expectation is. For example:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>Is an assertion that will fail, since <span class="tt">{a: 1}</span> has type <span class="tt">{a: number}</span> and not <span class="tt">{a: string}</span>. The error message in this case will read something like this:</p>
<div class="fragment"><div class="line">test/test.ts:999:999 - error TS2344: Type &#39;{ a: string; }&#39; does not satisfy the constraint &#39;{ a: \\&quot;Expected: string, Actual: number\\&quot;; }&#39;.</div>
<div class="line">  Types of property &#39;a&#39; are incompatible.</div>
<div class="line">    Type &#39;string&#39; is not assignable to type &#39;\\&quot;Expected: string, Actual: number\\&quot;&#39;.</div>
<div class="line"> </div>
<div class="line">999 expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>Note that the type constraint reported is a human-readable messaging specifying both the "expected" and "actual" types. Rather than taking the sentence <span class="tt">Types of property 'a' are incompatible // Type 'string' is not assignable to type "Expected: string, Actual: number"</span> literally - just look at the property name (<span class="tt">'a'</span>) and the message: <span class="tt">Expected: string, Actual: number</span>. This will tell you what's wrong, in most cases. Extremely complex types will, of course, be more effort to debug, and may require some experimentation. Please <a href="https://github.com/mmkal/expect-type">raise an issue</a> if the error messages are misleading.</p>
<p>The <span class="tt">toBe...</span> methods (like <span class="tt">toBeString</span>, <span class="tt">toBeNumber</span>, <span class="tt">toBeVoid</span>, etc.) fail by resolving to a non-callable type when the <span class="tt">Actual</span> type under test doesn't match up. For example, the failure for an assertion like <span class="tt">expectTypeOf(1).toBeString()</span> will look something like this:</p>
<div class="fragment"><div class="line">test/test.ts:999:999 - error TS2349: This expression is not callable.</div>
<div class="line">  Type &#39;ExpectString&lt;number&gt;&#39; has no call signatures.</div>
<div class="line"> </div>
<div class="line">999 expectTypeOf(1).toBeString()</div>
<div class="line">                    ~~~~~~~~~~</div>
</div><!-- fragment --><p>The <span class="tt">This expression is not callable</span> part isn't all that helpful - the meaningful error is the next line, <span class="tt">Type 'ExpectString&lt;number&gt; has no call signatures</span>. This essentially means you passed a number but asserted it should be a string.</p>
<p>If TypeScript added support for <a href="https://github.com/microsoft/TypeScript/pull/40468">"throw" types</a> these error messages could be improved. Until then they will take a certain amount of squinting.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md4552"></a>
Concrete "expected" objects vs type arguments</h3>
<p>Error messages for an assertion like this:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf({a: &#39;&#39;})</div>
</div><!-- fragment --><p>Will be less helpful than for an assertion like this:</p>
<div class="fragment"><div class="line">expectTypeOf({a: 1}).toEqualTypeOf&lt;{a: string}&gt;()</div>
</div><!-- fragment --><p>This is because the TypeScript compiler needs to infer the type argument for the <span class="tt">.toEqualTypeOf({a: ''})</span> style and this library can only mark it as a failure by comparing it against a generic <span class="tt">Mismatch</span> type. So, where possible, use a type argument rather than a concrete type for <span class="tt">.toEqualTypeOf</span> and <span class="tt">toMatchTypeOf</span>. If it's much more convenient to compare two concrete types, you can use <span class="tt">typeof</span>:</p>
<div class="fragment"><div class="line">const one = valueFromFunctionOne({some: {complex: inputs}})</div>
<div class="line">const two = valueFromFunctionTwo({some: {other: inputs}})</div>
<div class="line"> </div>
<div class="line">expectTypeOf(one).toEqualTypeof&lt;typeof two&gt;()</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md4553"></a>
Overloaded functions</h2>
<p>Due to a TypeScript <a href="https://github.com/microsoft/TypeScript/issues/32164#issuecomment-506810756">design limitation</a>, the native TypeScript <span class="tt">Parameters&lt;...&gt;</span> and <span class="tt">ReturnType&lt;...&gt;</span> helpers only return types from one variant of an overloaded function. This limitation doesn't apply to expect-type, since it is not used to author TypeScript code, only to assert on existing types. So, we use a workaround for this TypeScript behaviour to assert on <em>all</em> overloads as a union (actually, not necessarily <em>all</em> - we cap out at 10 overloads).</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4554"></a>
Within test frameworks</h2>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4555"></a>
Vitest</h2>
<p><span class="tt">expectTypeOf</span> is built in to <a href="https://vitest.dev/guide/testing-types">vitest</a>, so you can import <span class="tt">expectTypeOf</span> from the vitest library directly if you prefer. Note that there is no set release cadence, at time of writing, so vitest may not always be using the very latest version.</p>
<div class="fragment"><div class="line">import {expectTypeOf} from &#39;vitest&#39;</div>
<div class="line">import {mount} from &#39;./mount.js&#39;</div>
<div class="line"> </div>
<div class="line">test(&#39;my types work properly&#39;, () =&gt; {</div>
<div class="line">  expectTypeOf(mount).toBeFunction()</div>
<div class="line">  expectTypeOf(mount).parameter(0).toEqualTypeOf&lt;{name: string}&gt;()</div>
<div class="line"> </div>
<div class="line">  expectTypeOf(mount({name: 42})).toBeString()</div>
<div class="line">})</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md4556"></a>
Jest &amp; <span class="tt">eslint-plugin-jest</span></h3>
<p>If you're using Jest along with <span class="tt">eslint-plugin-jest</span>, and you put assertions inside <span class="tt">test(...)</span> definitions, you may get warnings from the <a href="https://github.com/jest-community/eslint-plugin-jest/blob/master/docs/rules/expect-expect.md"><span class="tt">jest/expect-expect</span></a> rule, complaining that "Test has no assertions" for tests that only use <span class="tt">expectTypeOf()</span>.</p>
<p>To remove this warning, configure the ESLint rule to consider <span class="tt">expectTypeOf</span> as an assertion:</p>
<div class="fragment"><div class="line">&quot;rules&quot;: {</div>
<div class="line">  // ...</div>
<div class="line">  &quot;jest/expect-expect&quot;: [</div>
<div class="line">    &quot;warn&quot;,</div>
<div class="line">    {</div>
<div class="line">      &quot;assertFunctionNames&quot;: [</div>
<div class="line">        &quot;expect&quot;, &quot;expectTypeOf&quot;</div>
<div class="line">      ]</div>
<div class="line">    }</div>
<div class="line">  ],</div>
<div class="line">  // ...</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md4557"></a>
Limitations</h2>
<p>A summary of some of the limitations of this library. Some of these are documented more fully elsewhere.</p>
<ol type="1">
<li>Intersection types can result in failures when the expected and actual types are not identically defined, even when they are effectively identical. See Why is my assertion failing for details. TL;DR: use <span class="tt">.brand</span> in these cases - and accept the performance hit that it comes with.</li>
</ol>
<ol type="1">
<li><span class="tt">toBeCallableWith</span> will likely fail if you try to use it with a generic function or an overload. See <a href="https://github.com/mmkal/expect-type/issues/50">this issue</a> for an example and how to work around it.</li>
</ol>
<ol type="1">
<li>(For now) overloaded functions might trip up the <span class="tt">.parameter</span> and <span class="tt">.parameters</span> helpers. This matches how the built-in TypeScript helper <span class="tt">Parameters&lt;...&gt;</span> works. This may be improved in the future though (<a href="https://github.com/mmkal/expect-type/issues/30">see related issue</a>).</li>
</ol>
<ol type="1">
<li><span class="tt">expectTypeOf(this).toEqualTypeOf(this)</span> inside class methods does not work.</li>
</ol>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4558"></a>
Similar projects</h1>
<p>Other projects with similar goals:</p>
<ul>
<li><a href="https://github.com/SamVerschueren/tsd"><span class="tt">tsd</span></a> is a CLI that runs the TypeScript type checker over assertions</li>
<li><a href="https://github.com/TypeStrong/ts-expect"><span class="tt">ts-expect</span></a> exports several generic helper types to perform type assertions</li>
<li><a href="https://github.com/Microsoft/dtslint"><span class="tt">dtslint</span></a> does type checks via comment directives and tslint</li>
<li><a href="https://github.com/unional/type-plus"><span class="tt">type-plus</span></a> comes with various type and runtime TypeScript assertions</li>
<li><a href="https://github.com/ksxnodemodules/static-type-assert"><span class="tt">static-type-assert</span></a> type assertion functions</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4559"></a>
Comparison</h2>
<p>The key differences in this project are:</p>
<ul>
<li>a fluent, jest-inspired API, making the difference between <span class="tt">actual</span> and <span class="tt">expected</span> clear. This is helpful with complex types and assertions.</li>
<li>inverting assertions intuitively and easily via <span class="tt">expectTypeOf(...).not</span></li>
<li>checks generics properly and strictly (<a href="https://github.com/SamVerschueren/tsd/issues/142">tsd doesn't</a>)</li>
<li>first-class support for:<ul>
<li><span class="tt">any</span> (as well as <span class="tt">unknown</span> and <span class="tt">never</span>) (see issues outstanding at time of writing in tsd for <a href="https://github.com/SamVerschueren/tsd/issues/78">never</a> and <a href="https://github.com/SamVerschueren/tsd/issues/82">any</a>).<ul>
<li>This can be especially useful in combination with <span class="tt">not</span>, to protect against functions returning too-permissive types. For example, <span class="tt">const parseFile = (filename: string) =&gt; JSON.parse(readFileSync(filename).toString())</span> returns <span class="tt">any</span>, which could lead to errors. After giving it a proper return-type, you can add a test for this with <span class="tt">expect(parseFile).returns.not.toBeAny()</span></li>
</ul>
</li>
<li>object properties</li>
<li>function parameters</li>
<li>function return values</li>
<li>constructor parameters</li>
<li>class instances</li>
<li>array item values</li>
<li>nullable types</li>
</ul>
</li>
<li>assertions on types "matching" rather than exact type equality, for "is-a" relationships e.g. <span class="tt">expectTypeOf(square).toExtend&lt;Shape&gt;()</span></li>
<li>built into existing tooling. No extra build step, cli tool, IDE extension, or lint plugin is needed. Just import the function and start writing tests. Failures will be at compile time - they'll appear in your IDE and when you run <span class="tt">tsc</span>.</li>
<li>small implementation with no dependencies. <a href="./src/index.ts">Take a look!</a> (tsd, for comparison, is <a href="https://bundlephobia.com/result?p=tsd@0.13.1">2.6MB</a> because it ships a patched version of TypeScript).</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4560"></a>
TypeScript backwards-compatibility</h1>
<p>There is a CI job called <span class="tt">test-types</span> that checks whether the tests still pass with certain older TypeScript versions. To check the supported TypeScript versions, <a href="./.github/workflows/ci.yml">refer to the job definition</a>.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md4561"></a>
Contributing</h1>
<p>In most cases, it's worth checking existing issues or creating one to discuss a new feature or a bug fix before opening a pull request.</p>
<p>Once you're ready to make a pull request: clone the repo, and install pnpm if you don't have it already with <span class="tt">npm install --global pnpm</span>. Lockfiles for <span class="tt">npm</span> and <span class="tt">yarn</span> are gitignored.</p>
<p>If you're adding a feature, you should write a self-contained usage example in the form of a test, in <a href="./test/usage.test.ts">test/usage.test.ts</a>. This file is used to populate the bulk of this readme using <a href="https://npmjs.com/package/eslint-plugin-codegen">eslint-plugin-codegen</a>, and to generate an <a href="./test/errors.test.ts">"errors" test file</a>, which captures the error messages that are emitted for failing assertions by the TypeScript compiler. So, the test name should be written as a human-readable sentence explaining the usage example. Have a look at the existing tests for an idea of the style.</p>
<p>After adding the tests, run <span class="tt">npm run lint -- --fix</span> to update the readme, and <span class="tt">npm test -- --updateSnapshot</span> to update the errors test. The generated documentation and tests should be pushed to the same branch as the source code, and submitted as a pull request. CI will test that the docs and tests are up to date if you forget to run these commands.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md4562"></a>
Documentation of limitations through tests</h2>
<p>Limitations of the library are documented through tests in <span class="tt">usage.test.ts</span>. This means that if a future TypeScript version (or library version) fixes the limitation, the test will start failing, and it will be automatically removed from the documentation once it no longer applies. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_b0ffaa9650680648f71633623b80e4c9.html">Eunice</a></li><li class="navelem"><a href="dir_06a7aea77c9c918e297ef6ec7ffe0f68.html">frontend</a></li><li class="navelem"><b>node_modules</b></li><li class="navelem"><a href="dir_76665c56dc29f8aaa2c6b8cdf863546c.html">expect-type</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for ACP - Autonomous Command Protocol by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
