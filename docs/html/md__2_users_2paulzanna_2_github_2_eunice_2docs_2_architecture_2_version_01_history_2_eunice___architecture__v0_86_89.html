<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACP - Autonomous Command Protocol: Eunice v0.6.9 Architecture — Real-time Notification System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACP - Autonomous Command Protocol<span id="projectnumber">&#160;v0.3.0</span>
   </div>
   <div id="projectbrief">Portable C99 framing library with COBS, CRC16, and HMAC-SHA256 authentication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('md__2_users_2paulzanna_2_github_2_eunice_2docs_2_architecture_2_version_01_history_2_eunice___architecture__v0_86_89.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Eunice v0.6.9 Architecture — Real-time Notification System </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1955"></a></p>
<p><b>Date:</b> 14-08-2025 <br  />
 <b>Owner:</b> Paul Zanna <br  />
 <b>Status:</b> Planning</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md1956"></a>
1) Executive Summary</h1>
<p>v0.6.9 introduces a <b>comprehensive real-time notification system</b> with <b>multi-channel delivery</b>, <b>intelligent routing</b>, <b>user preference management</b>, and <b>smart notification aggregation</b>. The system provides immediate awareness of critical events, completion alerts, and system updates while respecting user preferences and avoiding notification fatigue.</p>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1958"></a>
2) Scope</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1959"></a>
Goals</h2>
<ul>
<li><b>Real-time WebSocket Notifications</b>: Instant in-app notifications for critical events</li>
<li><b>Multi-channel Delivery</b>: Email, SMS, Slack, Teams, and webhook integrations</li>
<li><b>Intelligent Notification Routing</b>: Context-aware delivery based on urgency and user state</li>
<li><b>Smart Aggregation</b>: Bundle related notifications to reduce noise</li>
<li><b>User Preference Management</b>: Granular control over notification types and channels</li>
<li><b>Notification History &amp; Tracking</b>: Complete audit trail and delivery confirmation</li>
<li><b>Template Management</b>: Customizable notification templates for different event types</li>
<li><b>Escalation Workflows</b>: Automatic escalation for critical unacknowledged notifications</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1960"></a>
Non-Goals (this version)</h2>
<ul>
<li>Advanced AI-powered notification content generation</li>
<li>Integration with external CRM systems</li>
<li>Voice call notifications</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1962"></a>
3) High-Level Architecture</h1>
<div class="fragment"><div class="line">flowchart TD</div>
<div class="line">    subgraph &quot;Event Sources&quot;</div>
<div class="line">        TaskEvents[Task Events&lt;br/&gt;Completion/Failure]</div>
<div class="line">        WorkflowEvents[Workflow Events&lt;br/&gt;Milestones/Delays]</div>
<div class="line">        SystemEvents[System Events&lt;br/&gt;Alerts/Maintenance]</div>
<div class="line">        UserEvents[User Events&lt;br/&gt;Mentions/Assignments]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Notification Engine&quot;</div>
<div class="line">        EventBus[Event Bus&lt;br/&gt;Message Queue]</div>
<div class="line">        Router[Notification Router&lt;br/&gt;Intelligent Routing]</div>
<div class="line">        Aggregator[Smart Aggregator&lt;br/&gt;Batch Processing]</div>
<div class="line">        Templates[Template Engine&lt;br/&gt;Dynamic Content]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Delivery Channels&quot;</div>
<div class="line">        WebSocket[WebSocket&lt;br/&gt;Real-time In-app]</div>
<div class="line">        Email[Email Service&lt;br/&gt;SMTP/SendGrid]</div>
<div class="line">        SMS[SMS Gateway&lt;br/&gt;Twilio/AWS SNS]</div>
<div class="line">        Slack[Slack Integration&lt;br/&gt;Bot API]</div>
<div class="line">        Teams[Teams Integration&lt;br/&gt;Webhook API]</div>
<div class="line">        Webhooks[Custom Webhooks&lt;br/&gt;External Systems]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    subgraph &quot;Management Layer&quot;</div>
<div class="line">        Preferences[User Preferences&lt;br/&gt;Channel/Type Config]</div>
<div class="line">        History[Notification History&lt;br/&gt;Audit &amp; Tracking]</div>
<div class="line">        Analytics[Delivery Analytics&lt;br/&gt;Success Metrics]</div>
<div class="line">        Escalation[Escalation Engine&lt;br/&gt;Auto-escalation]</div>
<div class="line">    end</div>
<div class="line"> </div>
<div class="line">    TaskEvents --&gt; EventBus</div>
<div class="line">    WorkflowEvents --&gt; EventBus</div>
<div class="line">    SystemEvents --&gt; EventBus</div>
<div class="line">    UserEvents --&gt; EventBus</div>
<div class="line">    </div>
<div class="line">    EventBus --&gt; Router</div>
<div class="line">    Router --&gt; Aggregator</div>
<div class="line">    Aggregator --&gt; Templates</div>
<div class="line">    </div>
<div class="line">    Templates --&gt; WebSocket</div>
<div class="line">    Templates --&gt; Email</div>
<div class="line">    Templates --&gt; SMS</div>
<div class="line">    Templates --&gt; Slack</div>
<div class="line">    Templates --&gt; Teams</div>
<div class="line">    Templates --&gt; Webhooks</div>
<div class="line">    </div>
<div class="line">    Preferences --&gt; Router</div>
<div class="line">    Router --&gt; History</div>
<div class="line">    History --&gt; Analytics</div>
<div class="line">    Analytics --&gt; Escalation</div>
<div class="line">    </div>
<div class="line">    Escalation --&gt; Router</div>
</div><!-- fragment --><p><b>Key Properties</b></p>
<ul>
<li><b>Sub-second Delivery</b>: Critical notifications delivered within 1 second</li>
<li><b>High Availability</b>: 99.9% uptime with failover mechanisms</li>
<li><b>Scalable Processing</b>: Handle 100,000+ notifications per hour</li>
<li><b>Delivery Guarantees</b>: At-least-once delivery with deduplication</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1964"></a>
4) Components</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1965"></a>
4.1 Real-time WebSocket Service</h2>
<p><b>Technology</b>: WebSocket with Socket.IO for connection management</p>
<p><b>Features</b>:</p>
<ul>
<li>Persistent connections with automatic reconnection</li>
<li>Room-based notification targeting</li>
<li>Typing indicators and presence awareness</li>
<li>Connection state management and heartbeat monitoring</li>
<li>Mobile app support with background notifications</li>
<li>Offline queue management</li>
<li>Multi-tab synchronization</li>
<li>Progressive web app (PWA) push notifications</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1966"></a>
4.2 Multi-channel Notification Router</h2>
<p><b>Capabilities</b>:</p>
<ul>
<li>Intelligent channel selection based on user state</li>
<li>Priority-based routing with fallback channels</li>
<li>Rate limiting and throttling per channel</li>
<li>Delivery confirmation tracking</li>
<li>Failed delivery retry mechanisms</li>
<li>Channel health monitoring</li>
<li>A/B testing for notification effectiveness</li>
<li>Cost optimization for paid channels</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1967"></a>
4.3 Smart Notification Aggregation</h2>
<p><b>Capabilities</b>:</p>
<ul>
<li>Related event bundling within time windows</li>
<li>Duplicate notification detection and suppression</li>
<li>Priority-based aggregation rules</li>
<li>Context-aware grouping strategies</li>
<li>Summary generation for batched notifications</li>
<li>User activity-based aggregation timing</li>
<li>Threshold-based immediate delivery bypass</li>
<li>Customizable aggregation policies per user</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1968"></a>
4.4 Template Management System</h2>
<p><b>Capabilities</b>:</p>
<ul>
<li>Dynamic template rendering with variables</li>
<li>Multi-language template support</li>
<li>Rich content formatting (HTML, Markdown)</li>
<li>Template versioning and A/B testing</li>
<li>Brand customization and theming</li>
<li>Conditional content based on user context</li>
<li>Template performance analytics</li>
<li>Visual template editor interface</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1969"></a>
4.5 User Preference Engine</h2>
<p><b>Capabilities</b>:</p>
<ul>
<li>Granular notification type control</li>
<li>Channel preference management</li>
<li>Quiet hours and do-not-disturb settings</li>
<li>Frequency limits and cooldown periods</li>
<li>Context-based preference rules</li>
<li>Bulk preference management</li>
<li>Preference inheritance and defaults</li>
<li>Smart suggestion system</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1971"></a>
5) Data Model Extensions</h1>
<div class="fragment"><div class="line"><span class="comment">-- Notification events</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_events (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    event_type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    event_source <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- task, workflow, system, user</span></div>
<div class="line">    source_id UUID <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    severity <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;medium&#39;</span>, <span class="comment">-- low, medium, high, critical</span></div>
<div class="line">    title <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">255</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    message TEXT <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    metadata JSONB <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;{}&#39;</span>,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    expires_at TIMESTAMPTZ</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Notification delivery tracking</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_deliveries (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    event_id UUID <span class="keyword">REFERENCES</span> notification_events(id),</div>
<div class="line">    user_id UUID <span class="keyword">REFERENCES</span> users(id),</div>
<div class="line">    channel <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- websocket, email, sms, slack, teams</span></div>
<div class="line">    status <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;pending&#39;</span>, <span class="comment">-- pending, sent, delivered, failed, read</span></div>
<div class="line">    delivery_attempts <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">0</span>,</div>
<div class="line">    last_attempt_at TIMESTAMPTZ,</div>
<div class="line">    delivered_at TIMESTAMPTZ,</div>
<div class="line">    read_at TIMESTAMPTZ,</div>
<div class="line">    error_message TEXT,</div>
<div class="line">    metadata JSONB <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;{}&#39;</span>,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW()</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- User notification preferences</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_preferences (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    user_id UUID <span class="keyword">REFERENCES</span> users(id),</div>
<div class="line">    event_type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    channel <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    enabled <span class="keywordtype">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">TRUE</span>,</div>
<div class="line">    min_severity <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;medium&#39;</span>,</div>
<div class="line">    quiet_hours_start <span class="keywordtype">TIME</span>,</div>
<div class="line">    quiet_hours_end <span class="keywordtype">TIME</span>,</div>
<div class="line">    quiet_hours_timezone <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>),</div>
<div class="line">    max_frequency_per_hour <span class="keywordtype">INTEGER</span>,</div>
<div class="line">    aggregation_window_minutes <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">5</span>,</div>
<div class="line">    escalation_delay_minutes <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">15</span>,</div>
<div class="line">    metadata JSONB <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;{}&#39;</span>,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    updated_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    <span class="keyword">UNIQUE</span>(user_id, event_type, channel)</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Notification templates</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_templates (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    event_type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    channel <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    <span class="keyword">language</span> <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">10</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;en&#39;</span>,</div>
<div class="line">    subject_template TEXT,</div>
<div class="line">    content_template TEXT <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    content_type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;text&#39;</span>, <span class="comment">-- text, html, markdown</span></div>
<div class="line">    variables JSONB <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;[]&#39;</span>, <span class="comment">-- Available template variables</span></div>
<div class="line">    is_active <span class="keywordtype">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">TRUE</span>,</div>
<div class="line">    version <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">1</span>,</div>
<div class="line">    created_by UUID <span class="keyword">REFERENCES</span> users(id),</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    updated_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW()</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Aggregation groups</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_aggregations (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    user_id UUID <span class="keyword">REFERENCES</span> users(id),</div>
<div class="line">    group_key <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">255</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- For grouping related notifications</span></div>
<div class="line">    event_ids UUID[] <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    status <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;pending&#39;</span>, <span class="comment">-- pending, sent, expired</span></div>
<div class="line">    aggregation_rule <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>),</div>
<div class="line">    window_start TIMESTAMPTZ <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    window_end TIMESTAMPTZ <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    scheduled_delivery_at TIMESTAMPTZ,</div>
<div class="line">    delivered_at TIMESTAMPTZ,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW()</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Escalation rules</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> escalation_rules (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    event_type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">100</span>),</div>
<div class="line">    severity <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>),</div>
<div class="line">    initial_delay_minutes <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">15</span>,</div>
<div class="line">    escalation_steps JSONB <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- [{&quot;delay&quot;: 30, &quot;channels&quot;: [&quot;email&quot;]}, ...]</span></div>
<div class="line">    max_escalations <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">3</span>,</div>
<div class="line">    is_active <span class="keywordtype">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">TRUE</span>,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    updated_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW()</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line"><span class="comment">-- Channel configurations</span></div>
<div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> notification_channels (</div>
<div class="line">    id UUID <span class="keyword">PRIMARY</span> KEY <span class="keyword">DEFAULT</span> gen_random_uuid(),</div>
<div class="line">    name <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>,</div>
<div class="line">    type <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">50</span>) <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- email, sms, slack, teams, webhook</span></div>
<div class="line">    configuration JSONB <span class="keyword">NOT</span> <span class="stringliteral">NULL</span>, <span class="comment">-- Channel-specific settings</span></div>
<div class="line">    rate_limit_per_minute <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">60</span>,</div>
<div class="line">    retry_attempts <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">3</span>,</div>
<div class="line">    retry_delay_seconds <span class="keywordtype">INTEGER</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">30</span>,</div>
<div class="line">    is_active <span class="keywordtype">BOOLEAN</span> <span class="keyword">DEFAULT</span> <span class="stringliteral">TRUE</span>,</div>
<div class="line">    health_check_url TEXT,</div>
<div class="line">    last_health_check TIMESTAMPTZ,</div>
<div class="line">    health_status <span class="keywordtype">VARCHAR</span>(<span class="stringliteral">20</span>) <span class="keyword">DEFAULT</span> <span class="stringliteral">&#39;unknown&#39;</span>,</div>
<div class="line">    created_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW(),</div>
<div class="line">    updated_at TIMESTAMPTZ <span class="keyword">DEFAULT</span> NOW()</div>
<div class="line">);</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1973"></a>
6) Notification Event Types</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1974"></a>
6.1 Task-related Events</h2>
<div class="fragment"><div class="line">interface TaskNotificationEvents {</div>
<div class="line">  // Completion events</div>
<div class="line">  task_completed: {</div>
<div class="line">    task_id: string</div>
<div class="line">    task_title: string</div>
<div class="line">    completion_time: Duration</div>
<div class="line">    quality_score?: number</div>
<div class="line">    deliverables: string[]</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Failure events</div>
<div class="line">  task_failed: {</div>
<div class="line">    task_id: string</div>
<div class="line">    task_title: string</div>
<div class="line">    error_message: string</div>
<div class="line">    retry_count: number</div>
<div class="line">    next_retry_at?: Date</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Progress events</div>
<div class="line">  task_milestone_reached: {</div>
<div class="line">    task_id: string</div>
<div class="line">    milestone_name: string</div>
<div class="line">    progress_percentage: number</div>
<div class="line">    estimated_completion: Date</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Assignment events</div>
<div class="line">  task_assigned: {</div>
<div class="line">    task_id: string</div>
<div class="line">    assigned_to: string</div>
<div class="line">    assigned_by: string</div>
<div class="line">    due_date?: Date</div>
<div class="line">    priority: &#39;low&#39; | &#39;medium&#39; | &#39;high&#39; | &#39;critical&#39;</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1975"></a>
6.2 Workflow-related Events</h2>
<div class="fragment"><div class="line">interface WorkflowNotificationEvents {</div>
<div class="line">  // Workflow completion</div>
<div class="line">  workflow_completed: {</div>
<div class="line">    workflow_id: string</div>
<div class="line">    workflow_name: string</div>
<div class="line">    total_duration: Duration</div>
<div class="line">    tasks_completed: number</div>
<div class="line">    final_deliverables: string[]</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Workflow delays</div>
<div class="line">  workflow_delayed: {</div>
<div class="line">    workflow_id: string</div>
<div class="line">    expected_completion: Date</div>
<div class="line">    new_estimated_completion: Date</div>
<div class="line">    delay_reason: string</div>
<div class="line">    affected_tasks: string[]</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Critical path updates</div>
<div class="line">  critical_path_changed: {</div>
<div class="line">    workflow_id: string</div>
<div class="line">    new_critical_path: string[]</div>
<div class="line">    impact_on_completion: Duration</div>
<div class="line">    recommended_actions: string[]</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1976"></a>
6.3 System Events</h2>
<div class="fragment"><div class="line">interface SystemNotificationEvents {</div>
<div class="line">  // System health</div>
<div class="line">  system_maintenance_scheduled: {</div>
<div class="line">    maintenance_type: string</div>
<div class="line">    scheduled_start: Date</div>
<div class="line">    estimated_duration: Duration</div>
<div class="line">    affected_services: string[]</div>
<div class="line">    preparation_required: boolean</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Resource alerts</div>
<div class="line">  resource_shortage_detected: {</div>
<div class="line">    resource_type: string</div>
<div class="line">    current_availability: number</div>
<div class="line">    minimum_required: number</div>
<div class="line">    affected_tasks: string[]</div>
<div class="line">    recommended_actions: string[]</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  // Security events</div>
<div class="line">  security_alert: {</div>
<div class="line">    alert_type: string</div>
<div class="line">    severity: &#39;low&#39; | &#39;medium&#39; | &#39;high&#39; | &#39;critical&#39;</div>
<div class="line">    description: string</div>
<div class="line">    affected_systems: string[]</div>
<div class="line">    immediate_actions_required: boolean</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1978"></a>
7) Delivery Channels Implementation</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1979"></a>
7.1 WebSocket Real-time Notifications</h2>
<div class="fragment"><div class="line">class WebSocketNotificationService {</div>
<div class="line">  private io: Server</div>
<div class="line">  private userConnections = new Map&lt;string, Set&lt;string&gt;&gt;() // userId -&gt; socketIds</div>
<div class="line">  </div>
<div class="line">  async sendToUser(userId: string, notification: Notification): Promise&lt;void&gt; {</div>
<div class="line">    const socketIds = this.userConnections.get(userId)</div>
<div class="line">    if (!socketIds?.size) {</div>
<div class="line">      // User not connected, queue for delivery when they connect</div>
<div class="line">      await this.queueOfflineNotification(userId, notification)</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    for (const socketId of socketIds) {</div>
<div class="line">      this.io.to(socketId).emit(&#39;notification&#39;, {</div>
<div class="line">        id: notification.id,</div>
<div class="line">        type: notification.event_type,</div>
<div class="line">        title: notification.title,</div>
<div class="line">        message: notification.message,</div>
<div class="line">        severity: notification.severity,</div>
<div class="line">        timestamp: notification.created_at,</div>
<div class="line">        metadata: notification.metadata,</div>
<div class="line">        actions: this.generateNotificationActions(notification)</div>
<div class="line">      })</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    await this.markAsDelivered(notification.id, &#39;websocket&#39;)</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private generateNotificationActions(notification: Notification): NotificationAction[] {</div>
<div class="line">    const actions: NotificationAction[] = [</div>
<div class="line">      { type: &#39;dismiss&#39;, label: &#39;Dismiss&#39; }</div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    // Add context-specific actions</div>
<div class="line">    if (notification.event_type === &#39;task_completed&#39;) {</div>
<div class="line">      actions.push(</div>
<div class="line">        { type: &#39;view_task&#39;, label: &#39;View Task&#39;, url: `/tasks/${notification.metadata.task_id}` },</div>
<div class="line">        { type: &#39;view_deliverables&#39;, label: &#39;View Results&#39;, url: `/tasks/${notification.metadata.task_id}/deliverables` }</div>
<div class="line">      )</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return actions</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1980"></a>
7.2 Email Notification Service</h2>
<div class="fragment"><div class="line">class EmailNotificationService {</div>
<div class="line">  private transporter: nodemailer.Transporter</div>
<div class="line">  private templateEngine: TemplateEngine</div>
<div class="line">  </div>
<div class="line">  async sendNotification(</div>
<div class="line">    recipient: string,</div>
<div class="line">    notification: Notification,</div>
<div class="line">    template: NotificationTemplate</div>
<div class="line">  ): Promise&lt;DeliveryResult&gt; {</div>
<div class="line">    try {</div>
<div class="line">      const renderedContent = await this.templateEngine.render(template, {</div>
<div class="line">        ...notification.metadata,</div>
<div class="line">        title: notification.title,</div>
<div class="line">        message: notification.message,</div>
<div class="line">        timestamp: notification.created_at,</div>
<div class="line">        unsubscribe_url: this.generateUnsubscribeUrl(recipient, notification.event_type)</div>
<div class="line">      })</div>
<div class="line">      </div>
<div class="line">      const mailOptions = {</div>
<div class="line">        from: process.env.NOTIFICATION_FROM_EMAIL,</div>
<div class="line">        to: recipient,</div>
<div class="line">        subject: renderedContent.subject,</div>
<div class="line">        html: renderedContent.html,</div>
<div class="line">        text: renderedContent.text,</div>
<div class="line">        headers: {</div>
<div class="line">          &#39;X-Notification-ID&#39;: notification.id,</div>
<div class="line">          &#39;X-Event-Type&#39;: notification.event_type</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">      </div>
<div class="line">      const result = await this.transporter.sendMail(mailOptions)</div>
<div class="line">      </div>
<div class="line">      return {</div>
<div class="line">        success: true,</div>
<div class="line">        messageId: result.messageId,</div>
<div class="line">        deliveredAt: new Date()</div>
<div class="line">      }</div>
<div class="line">    } catch (error) {</div>
<div class="line">      return {</div>
<div class="line">        success: false,</div>
<div class="line">        error: error.message,</div>
<div class="line">        retryable: this.isRetryableError(error)</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1981"></a>
7.3 Slack Integration Service</h2>
<div class="fragment"><div class="line">class SlackNotificationService {</div>
<div class="line">  private slackClient: WebClient</div>
<div class="line">  </div>
<div class="line">  async sendNotification(</div>
<div class="line">    channel: string,</div>
<div class="line">    notification: Notification,</div>
<div class="line">    userSlackId?: string</div>
<div class="line">  ): Promise&lt;DeliveryResult&gt; {</div>
<div class="line">    try {</div>
<div class="line">      const blocks = this.createSlackBlocks(notification)</div>
<div class="line">      </div>
<div class="line">      const result = await this.slackClient.chat.postMessage({</div>
<div class="line">        channel: userSlackId || channel,</div>
<div class="line">        blocks,</div>
<div class="line">        text: notification.title, // Fallback text</div>
<div class="line">        unfurl_links: false</div>
<div class="line">      })</div>
<div class="line">      </div>
<div class="line">      return {</div>
<div class="line">        success: true,</div>
<div class="line">        messageId: result.ts,</div>
<div class="line">        deliveredAt: new Date()</div>
<div class="line">      }</div>
<div class="line">    } catch (error) {</div>
<div class="line">      return {</div>
<div class="line">        success: false,</div>
<div class="line">        error: error.message,</div>
<div class="line">        retryable: error.data?.error !== &#39;channel_not_found&#39;</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private createSlackBlocks(notification: Notification): Block[] {</div>
<div class="line">    const blocks: Block[] = [</div>
<div class="line">      {</div>
<div class="line">        type: &#39;header&#39;,</div>
<div class="line">        text: {</div>
<div class="line">          type: &#39;plain_text&#39;,</div>
<div class="line">          text: notification.title</div>
<div class="line">        }</div>
<div class="line">      },</div>
<div class="line">      {</div>
<div class="line">        type: &#39;section&#39;,</div>
<div class="line">        text: {</div>
<div class="line">          type: &#39;mrkdwn&#39;,</div>
<div class="line">          text: notification.message</div>
<div class="line">        }</div>
<div class="line">      }</div>
<div class="line">    ]</div>
<div class="line">    </div>
<div class="line">    // Add action buttons for interactive notifications</div>
<div class="line">    if (notification.event_type === &#39;task_completed&#39;) {</div>
<div class="line">      blocks.push({</div>
<div class="line">        type: &#39;actions&#39;,</div>
<div class="line">        elements: [</div>
<div class="line">          {</div>
<div class="line">            type: &#39;button&#39;,</div>
<div class="line">            text: { type: &#39;plain_text&#39;, text: &#39;View Task&#39; },</div>
<div class="line">            url: `${process.env.FRONTEND_URL}/tasks/${notification.metadata.task_id}`,</div>
<div class="line">            action_id: &#39;view_task&#39;</div>
<div class="line">          }</div>
<div class="line">        ]</div>
<div class="line">      })</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return blocks</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1983"></a>
8) Smart Aggregation Engine</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1984"></a>
8.1 Aggregation Rules Engine</h2>
<div class="fragment"><div class="line">class NotificationAggregator {</div>
<div class="line">  private aggregationRules: Map&lt;string, AggregationRule&gt; = new Map()</div>
<div class="line">  </div>
<div class="line">  async processEvent(event: NotificationEvent): Promise&lt;void&gt; {</div>
<div class="line">    const rule = this.getAggregationRule(event.event_type)</div>
<div class="line">    if (!rule) {</div>
<div class="line">      // No aggregation, send immediately</div>
<div class="line">      await this.sendImmediateNotification(event)</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    const groupKey = this.generateGroupKey(event, rule)</div>
<div class="line">    const existingGroup = await this.findActiveGroup(event.user_id, groupKey)</div>
<div class="line">    </div>
<div class="line">    if (existingGroup) {</div>
<div class="line">      // Add to existing group</div>
<div class="line">      await this.addToGroup(existingGroup.id, event.id)</div>
<div class="line">      await this.updateGroupSchedule(existingGroup.id, rule)</div>
<div class="line">    } else {</div>
<div class="line">      // Create new aggregation group</div>
<div class="line">      await this.createAggregationGroup(event, groupKey, rule)</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private generateGroupKey(event: NotificationEvent, rule: AggregationRule): string {</div>
<div class="line">    const keyParts = rule.groupBy.map(field =&gt; {</div>
<div class="line">      switch (field) {</div>
<div class="line">        case &#39;source_id&#39;:</div>
<div class="line">          return event.source_id</div>
<div class="line">        case &#39;event_type_category&#39;:</div>
<div class="line">          return this.getEventTypeCategory(event.event_type)</div>
<div class="line">        case &#39;severity&#39;:</div>
<div class="line">          return event.severity</div>
<div class="line">        default:</div>
<div class="line">          return event.metadata[field] || &#39;unknown&#39;</div>
<div class="line">      }</div>
<div class="line">    })</div>
<div class="line">    </div>
<div class="line">    return keyParts.join(&#39;:&#39;)</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  async deliverAggregatedNotification(groupId: string): Promise&lt;void&gt; {</div>
<div class="line">    const group = await this.getAggregationGroup(groupId)</div>
<div class="line">    const events = await this.getGroupEvents(group.event_ids)</div>
<div class="line">    </div>
<div class="line">    const aggregatedNotification = this.createAggregatedNotification(events)</div>
<div class="line">    await this.deliverNotification(group.user_id, aggregatedNotification)</div>
<div class="line">    </div>
<div class="line">    // Mark group as delivered</div>
<div class="line">    await this.markGroupDelivered(groupId)</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1985"></a>
8.2 Intelligent Scheduling</h2>
<div class="fragment"><div class="line">interface AggregationRule {</div>
<div class="line">  eventType: string</div>
<div class="line">  windowDuration: Duration // How long to wait for more events</div>
<div class="line">  maxEvents: number // Maximum events to aggregate</div>
<div class="line">  groupBy: string[] // Fields to group by</div>
<div class="line">  deliveryStrategy: &#39;time_window&#39; | &#39;user_activity&#39; | &#39;threshold&#39;</div>
<div class="line">  </div>
<div class="line">  // Smart delivery timing</div>
<div class="line">  respectQuietHours: boolean</div>
<div class="line">  deliverOnUserActivity: boolean // Deliver when user is active</div>
<div class="line">  minDeliveryDelay: Duration // Minimum time before delivery</div>
<div class="line">  maxDeliveryDelay: Duration // Maximum time before forced delivery</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class SmartScheduler {</div>
<div class="line">  async scheduleDelivery(</div>
<div class="line">    groupId: string,</div>
<div class="line">    rule: AggregationRule,</div>
<div class="line">    userActivity: UserActivity</div>
<div class="line">  ): Promise&lt;Date&gt; {</div>
<div class="line">    const baseDeliveryTime = new Date(Date.now() + rule.windowDuration.toMilliseconds())</div>
<div class="line">    </div>
<div class="line">    // Adjust for user activity</div>
<div class="line">    if (rule.deliverOnUserActivity &amp;&amp; userActivity.isActive) {</div>
<div class="line">      // Deliver sooner if user is currently active</div>
<div class="line">      return new Date(Date.now() + Math.min(rule.minDeliveryDelay.toMilliseconds(), 30000))</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // Respect quiet hours</div>
<div class="line">    if (rule.respectQuietHours) {</div>
<div class="line">      const adjustedTime = this.adjustForQuietHours(baseDeliveryTime, userActivity.preferences)</div>
<div class="line">      return adjustedTime</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return baseDeliveryTime</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private adjustForQuietHours(deliveryTime: Date, preferences: UserPreferences): Date {</div>
<div class="line">    if (!preferences.quietHours) return deliveryTime</div>
<div class="line">    </div>
<div class="line">    const userTime = this.convertToUserTimezone(deliveryTime, preferences.timezone)</div>
<div class="line">    const quietStart = preferences.quietHours.start</div>
<div class="line">    const quietEnd = preferences.quietHours.end</div>
<div class="line">    </div>
<div class="line">    if (this.isInQuietHours(userTime, quietStart, quietEnd)) {</div>
<div class="line">      // Schedule for end of quiet hours</div>
<div class="line">      const nextDeliveryTime = this.getEndOfQuietHours(userTime, quietEnd)</div>
<div class="line">      return this.convertFromUserTimezone(nextDeliveryTime, preferences.timezone)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    return deliveryTime</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1987"></a>
9) Escalation System</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1988"></a>
9.1 Escalation Engine</h2>
<div class="fragment"><div class="line">class EscalationEngine {</div>
<div class="line">  async processEscalation(notificationId: string): Promise&lt;void&gt; {</div>
<div class="line">    const delivery = await this.getNotificationDelivery(notificationId)</div>
<div class="line">    if (delivery.status === &#39;read&#39;) {</div>
<div class="line">      // User has read the notification, no escalation needed</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    const escalationRule = await this.getEscalationRule(delivery.event_type, delivery.severity)</div>
<div class="line">    if (!escalationRule) return</div>
<div class="line">    </div>
<div class="line">    const currentStep = await this.getCurrentEscalationStep(notificationId)</div>
<div class="line">    const nextStep = escalationRule.steps[currentStep]</div>
<div class="line">    </div>
<div class="line">    if (!nextStep || currentStep &gt;= escalationRule.maxEscalations) {</div>
<div class="line">      // No more escalation steps</div>
<div class="line">      await this.markEscalationComplete(notificationId)</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // Execute escalation step</div>
<div class="line">    await this.executeEscalationStep(notificationId, nextStep)</div>
<div class="line">    </div>
<div class="line">    // Schedule next escalation if needed</div>
<div class="line">    if (currentStep + 1 &lt; escalationRule.steps.length) {</div>
<div class="line">      await this.scheduleNextEscalation(</div>
<div class="line">        notificationId,</div>
<div class="line">        escalationRule.steps[currentStep + 1].delay</div>
<div class="line">      )</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private async executeEscalationStep(</div>
<div class="line">    notificationId: string,</div>
<div class="line">    step: EscalationStep</div>
<div class="line">  ): Promise&lt;void&gt; {</div>
<div class="line">    const originalDelivery = await this.getNotificationDelivery(notificationId)</div>
<div class="line">    const event = await this.getNotificationEvent(originalDelivery.event_id)</div>
<div class="line">    </div>
<div class="line">    for (const channel of step.channels) {</div>
<div class="line">      if (channel === &#39;manager_email&#39;) {</div>
<div class="line">        // Escalate to user&#39;s manager</div>
<div class="line">        const manager = await this.getUserManager(originalDelivery.user_id)</div>
<div class="line">        if (manager) {</div>
<div class="line">          await this.sendEscalationNotification(manager.email, event, &#39;email&#39;)</div>
<div class="line">        }</div>
<div class="line">      } else if (channel === &#39;emergency_sms&#39;) {</div>
<div class="line">        // Send SMS for critical alerts</div>
<div class="line">        const user = await this.getUser(originalDelivery.user_id)</div>
<div class="line">        if (user.phone) {</div>
<div class="line">          await this.sendEscalationNotification(user.phone, event, &#39;sms&#39;)</div>
<div class="line">        }</div>
<div class="line">      } else {</div>
<div class="line">        // Regular channel escalation</div>
<div class="line">        await this.sendEscalationNotification(</div>
<div class="line">          originalDelivery.user_id,</div>
<div class="line">          event,</div>
<div class="line">          channel</div>
<div class="line">        )</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1990"></a>
10) Performance Optimization</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1991"></a>
10.1 Message Queue Architecture</h2>
<div class="fragment"><div class="line">// Using Redis Streams for reliable message processing</div>
<div class="line">class NotificationQueue {</div>
<div class="line">  private redis: Redis</div>
<div class="line">  </div>
<div class="line">  async enqueueNotification(notification: NotificationEvent): Promise&lt;void&gt; {</div>
<div class="line">    await this.redis.xadd(</div>
<div class="line">      &#39;notifications:queue&#39;,</div>
<div class="line">      &#39;*&#39;,</div>
<div class="line">      &#39;event_id&#39;, notification.id,</div>
<div class="line">      &#39;user_id&#39;, notification.user_id,</div>
<div class="line">      &#39;priority&#39;, notification.severity,</div>
<div class="line">      &#39;data&#39;, JSON.stringify(notification)</div>
<div class="line">    )</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  async processNotifications(): Promise&lt;void&gt; {</div>
<div class="line">    const consumerGroup = &#39;notification-processors&#39;</div>
<div class="line">    const consumer = `processor-${process.env.HOSTNAME}`</div>
<div class="line">    </div>
<div class="line">    while (true) {</div>
<div class="line">      try {</div>
<div class="line">        const messages = await this.redis.xreadgroup(</div>
<div class="line">          &#39;GROUP&#39;, consumerGroup, consumer,</div>
<div class="line">          &#39;COUNT&#39;, 10,</div>
<div class="line">          &#39;BLOCK&#39;, 1000,</div>
<div class="line">          &#39;STREAMS&#39;, &#39;notifications:queue&#39;, &#39;&gt;&#39;</div>
<div class="line">        )</div>
<div class="line">        </div>
<div class="line">        for (const [stream, entries] of messages) {</div>
<div class="line">          for (const [id, fields] of entries) {</div>
<div class="line">            await this.processMessage(id, fields)</div>
<div class="line">            await this.redis.xack(&#39;notifications:queue&#39;, consumerGroup, id)</div>
<div class="line">          }</div>
<div class="line">        }</div>
<div class="line">      } catch (error) {</div>
<div class="line">        console.error(&#39;Error processing notifications:&#39;, error)</div>
<div class="line">        await new Promise(resolve =&gt; setTimeout(resolve, 5000))</div>
<div class="line">      }</div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1992"></a>
10.2 Connection Management</h2>
<div class="fragment"><div class="line">class WebSocketConnectionManager {</div>
<div class="line">  private connections = new Map&lt;string, UserConnection&gt;()</div>
<div class="line">  private heartbeatInterval = 30000 // 30 seconds</div>
<div class="line">  </div>
<div class="line">  onConnection(socket: Socket): void {</div>
<div class="line">    const userId = this.authenticateSocket(socket)</div>
<div class="line">    if (!userId) {</div>
<div class="line">      socket.disconnect()</div>
<div class="line">      return</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    const connection: UserConnection = {</div>
<div class="line">      socketId: socket.id,</div>
<div class="line">      userId,</div>
<div class="line">      connectedAt: new Date(),</div>
<div class="line">      lastSeen: new Date(),</div>
<div class="line">      isActive: true</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    this.connections.set(socket.id, connection)</div>
<div class="line">    this.startHeartbeat(socket)</div>
<div class="line">    </div>
<div class="line">    // Deliver queued offline notifications</div>
<div class="line">    this.deliverOfflineNotifications(userId)</div>
<div class="line">  }</div>
<div class="line">  </div>
<div class="line">  private startHeartbeat(socket: Socket): void {</div>
<div class="line">    const interval = setInterval(() =&gt; {</div>
<div class="line">      socket.emit(&#39;ping&#39;)</div>
<div class="line">      </div>
<div class="line">      const timeout = setTimeout(() =&gt; {</div>
<div class="line">        // Connection is stale, disconnect</div>
<div class="line">        socket.disconnect()</div>
<div class="line">        clearInterval(interval)</div>
<div class="line">      }, 5000)</div>
<div class="line">      </div>
<div class="line">      socket.once(&#39;pong&#39;, () =&gt; {</div>
<div class="line">        clearTimeout(timeout)</div>
<div class="line">        this.updateLastSeen(socket.id)</div>
<div class="line">      })</div>
<div class="line">    }, this.heartbeatInterval)</div>
<div class="line">    </div>
<div class="line">    socket.on(&#39;disconnect&#39;, () =&gt; {</div>
<div class="line">      clearInterval(interval)</div>
<div class="line">      this.connections.delete(socket.id)</div>
<div class="line">    })</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1994"></a>
11) Testing Strategy</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1995"></a>
11.1 Notification Delivery Testing</h2>
<div class="fragment"><div class="line">describe(&#39;Notification Delivery&#39;, () =&gt; {</div>
<div class="line">  test(&#39;delivers high-priority notifications immediately&#39;, async () =&gt; {</div>
<div class="line">    const event = createCriticalTaskFailureEvent()</div>
<div class="line">    </div>
<div class="line">    await notificationService.processEvent(event)</div>
<div class="line">    </div>
<div class="line">    // Should deliver via WebSocket immediately</div>
<div class="line">    expect(mockWebSocket.emit).toHaveBeenCalledWith(&#39;notification&#39;, expect.objectContaining({</div>
<div class="line">      severity: &#39;critical&#39;,</div>
<div class="line">      type: &#39;task_failed&#39;</div>
<div class="line">    }))</div>
<div class="line">    </div>
<div class="line">    // Should also trigger email for critical events</div>
<div class="line">    expect(mockEmailService.send).toHaveBeenCalled()</div>
<div class="line">  })</div>
<div class="line">  </div>
<div class="line">  test(&#39;aggregates low-priority notifications&#39;, async () =&gt; {</div>
<div class="line">    const events = Array.from({ length: 5 }, () =&gt; createTaskCompletedEvent())</div>
<div class="line">    </div>
<div class="line">    for (const event of events) {</div>
<div class="line">      await notificationService.processEvent(event)</div>
<div class="line">    }</div>
<div class="line">    </div>
<div class="line">    // Should create aggregation group</div>
<div class="line">    const groups = await db.getAggregationGroups()</div>
<div class="line">    expect(groups).toHaveLength(1)</div>
<div class="line">    expect(groups[0].event_ids).toHaveLength(5)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md1996"></a>
11.2 Channel Integration Testing</h2>
<div class="fragment"><div class="line">describe(&#39;Channel Integrations&#39;, () =&gt; {</div>
<div class="line">  test(&#39;handles Slack API failures gracefully&#39;, async () =&gt; {</div>
<div class="line">    mockSlackClient.chat.postMessage.mockRejectedValue(new Error(&#39;channel_not_found&#39;))</div>
<div class="line">    </div>
<div class="line">    const result = await slackService.sendNotification(&#39;invalid-channel&#39;, notification)</div>
<div class="line">    </div>
<div class="line">    expect(result.success).toBe(false)</div>
<div class="line">    expect(result.retryable).toBe(false)</div>
<div class="line">  })</div>
<div class="line">  </div>
<div class="line">  test(&#39;retries transient email failures&#39;, async () =&gt; {</div>
<div class="line">    mockTransporter.sendMail</div>
<div class="line">      .mockRejectedValueOnce(new Error(&#39;Rate limit exceeded&#39;))</div>
<div class="line">      .mockResolvedValueOnce({ messageId: &#39;test-id&#39; })</div>
<div class="line">    </div>
<div class="line">    const result = await emailService.sendNotification(&#39;test@example.com&#39;, notification, template)</div>
<div class="line">    </div>
<div class="line">    expect(result.success).toBe(true)</div>
<div class="line">    expect(mockTransporter.sendMail).toHaveBeenCalledTimes(2)</div>
<div class="line">  })</div>
<div class="line">})</div>
</div><!-- fragment --><hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md1998"></a>
12) Acceptance Criteria</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md1999"></a>
Core Functionality</h2>
<ul class="check">
<li class="unchecked">WebSocket notifications delivered within 1 second of events</li>
</ul>
<ul class="check">
<li class="unchecked">Multi-channel delivery works for all supported channels</li>
</ul>
<ul class="check">
<li class="unchecked">User preferences are respected for all notification types</li>
</ul>
<ul class="check">
<li class="unchecked">Smart aggregation reduces notification volume by &gt;60%</li>
</ul>
<ul class="check">
<li class="unchecked">Escalation workflows trigger correctly for unread critical notifications</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2000"></a>
Performance Requirements</h2>
<ul class="check">
<li class="unchecked">System handles 100,000 notifications per hour</li>
</ul>
<ul class="check">
<li class="unchecked">WebSocket connections maintain 99.5% uptime</li>
</ul>
<ul class="check">
<li class="unchecked">Email delivery has &gt;95% success rate</li>
</ul>
<ul class="check">
<li class="unchecked">Notification processing latency &lt;500ms</li>
</ul>
<ul class="check">
<li class="unchecked">Database queries complete within 100ms</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2001"></a>
User Experience Requirements</h2>
<ul class="check">
<li class="unchecked">In-app notifications are visually appealing and actionable</li>
</ul>
<ul class="check">
<li class="unchecked">Preference management interface is intuitive</li>
</ul>
<ul class="check">
<li class="unchecked">Notification history is searchable and filterable</li>
</ul>
<ul class="check">
<li class="unchecked">Mobile notifications work reliably across platforms</li>
</ul>
<ul class="check">
<li class="unchecked">Unsubscribe mechanisms work for all channels</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md2002"></a>
Integration Requirements</h2>
<ul class="check">
<li class="unchecked">Slack integration handles workspace permissions</li>
</ul>
<ul class="check">
<li class="unchecked">Teams integration works with organization policies</li>
</ul>
<ul class="check">
<li class="unchecked">Webhook delivery has retry and authentication support</li>
</ul>
<ul class="check">
<li class="unchecked">SMS delivery handles international numbers</li>
</ul>
<ul class="check">
<li class="unchecked">Email templates render correctly across mail clients</li>
</ul>
<hr  />
<h1 class="doxsection"><a class="anchor" id="autotoc_md2004"></a>
13) Success Metrics</h1>
<ul>
<li><b>Delivery Success Rate</b>: &gt;98% successful delivery across all channels</li>
<li><b>User Engagement</b>: &gt;70% of notifications are read within 1 hour</li>
<li><b>Noise Reduction</b>: &gt;60% reduction in notification volume through aggregation</li>
<li><b>Response Time</b>: Critical notifications acknowledged within 5 minutes</li>
<li><b>System Reliability</b>: 99.9% uptime for notification services </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on <span class="timestamp"></span> for ACP - Autonomous Command Protocol by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
