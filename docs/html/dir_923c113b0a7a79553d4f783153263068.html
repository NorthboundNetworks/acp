<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.15.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ACP - Autonomous Command Protocol: /Users/paulzanna/Github/Eunice/frontend/node_modules/tar Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">ACP - Autonomous Command Protocol<span id="projectnumber">&#160;v0.3.0</span>
   </div>
   <div id="projectbrief">Portable C99 framing library with COBS, CRC16, and HMAC-SHA256 authentication</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.15.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_923c113b0a7a79553d4f783153263068.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">tar Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<h1 class="doxsection"><a class="anchor" id="autotoc_md6557"></a>
node-tar</h1>
<p>Fast and full-featured Tar for Node.js</p>
<p>The API is designed to mimic the behavior of <span class="tt">tar(1)</span> on unix systems. If you are familiar with how tar works, most of this will hopefully be straightforward for you. If not, then hopefully this module can teach you useful unix skills that may come in handy someday :)</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md6558"></a>
Background</h1>
<p>A "tar file" or "tarball" is an archive of file system entries (directories, files, links, etc.) The name comes from "tape archive". If you run <span class="tt">man tar</span> on almost any Unix command line, you'll learn quite a bit about what it can do, and its history.</p>
<p>Tar has 5 main top-level commands:</p>
<ul>
<li><span class="tt">c</span> Create an archive</li>
<li><span class="tt">r</span> Replace entries within an archive</li>
<li><span class="tt">u</span> Update entries within an archive (ie, replace if they're newer)</li>
<li><span class="tt">t</span> List out the contents of an archive</li>
<li><span class="tt">x</span> Extract an archive to disk</li>
</ul>
<p>The other flags and options modify how this top level function works.</p>
<h1 class="doxsection"><a class="anchor" id="autotoc_md6559"></a>
High-Level API</h1>
<p>These 5 functions are the high-level API. All of them have a single-character name (for unix nerds familiar with <span class="tt">tar(1)</span>) as well as a long name (for everyone else).</p>
<p>All the high-level functions take the following arguments, all three of which are optional and may be omitted.</p>
<ol type="1">
<li><span class="tt">options</span> - An optional object specifying various options</li>
<li><span class="tt">paths</span> - An array of paths to add or extract</li>
<li><span class="tt">callback</span> - Called when the command is completed, if async. (If sync or no file specified, providing a callback throws a <span class="tt">TypeError</span>.)</li>
</ol>
<p>If the command is sync (ie, if <span class="tt">options.sync=true</span>), then the callback is not allowed, since the action will be completed immediately.</p>
<p>If a <span class="tt">file</span> argument is specified, and the command is async, then a <span class="tt">Promise</span> is returned. In this case, if async, a callback may be provided which is called when the command is completed.</p>
<p>If a <span class="tt">file</span> option is not specified, then a stream is returned. For <span class="tt">create</span>, this is a readable stream of the generated archive. For <span class="tt">list</span> and <span class="tt">extract</span> this is a writable stream that an archive should be written into. If a file is not specified, then a callback is not allowed, because you're already getting a stream to work with.</p>
<p><span class="tt">replace</span> and <span class="tt">update</span> only work on existing archives, and so require a <span class="tt">file</span> argument.</p>
<p>Sync commands without a file argument return a stream that acts on its input immediately in the same tick. For readable streams, this means that all of the data is immediately available by calling <span class="tt">stream.read()</span>. For writable streams, it will be acted upon as soon as it is provided, but this can be at any time.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6560"></a>
Warnings and Errors</h2>
<p>Tar emits warnings and errors for recoverable and unrecoverable situations, respectively. In many cases, a warning only affects a single entry in an archive, or is simply informing you that it's modifying an entry to comply with the settings provided.</p>
<p>Unrecoverable warnings will always raise an error (ie, emit <span class="tt">'error'</span> on streaming actions, throw for non-streaming sync actions, reject the returned Promise for non-streaming async operations, or call a provided callback with an <span class="tt">Error</span> as the first argument). Recoverable errors will raise an error only if <span class="tt">strict: true</span> is set in the options.</p>
<p>Respond to (recoverable) warnings by listening to the <span class="tt">warn</span> event. Handlers receive 3 arguments:</p>
<ul>
<li><span class="tt">code</span> String. One of the error codes below. This may not match <span class="tt">data.code</span>, which preserves the original error code from fs and zlib.</li>
<li><span class="tt">message</span> String. More details about the error.</li>
<li><span class="tt">data</span> Metadata about the error. An <span class="tt">Error</span> object for errors raised by fs and zlib. All fields are attached to errors raisd by tar. Typically contains the following fields, as relevant:<ul>
<li><span class="tt">tarCode</span> The tar error code.</li>
<li><span class="tt">code</span> Either the tar error code, or the error code set by the underlying system.</li>
<li><span class="tt">file</span> The archive file being read or written.</li>
<li><span class="tt">cwd</span> Working directory for creation and extraction operations.</li>
<li><span class="tt">entry</span> The entry object (if it could be created) for <span class="tt">TAR_ENTRY_INFO</span>, <span class="tt">TAR_ENTRY_INVALID</span>, and <span class="tt">TAR_ENTRY_ERROR</span> warnings.</li>
<li><span class="tt">header</span> The header object (if it could be created, and the entry could not be created) for <span class="tt">TAR_ENTRY_INFO</span> and <span class="tt">TAR_ENTRY_INVALID</span> warnings.</li>
<li><span class="tt">recoverable</span> Boolean. If <span class="tt">false</span>, then the warning will emit an <span class="tt">error</span>, even in non-strict mode.</li>
</ul>
</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6561"></a>
Error Codes</h3>
<ul>
<li><span class="tt">TAR_ENTRY_INFO</span> An informative error indicating that an entry is being modified, but otherwise processed normally. For example, removing <span class="tt">/</span> or <span class="tt">C:\</span> from absolute paths if <span class="tt">preservePaths</span> is not set.</li>
<li><p class="startli"><span class="tt">TAR_ENTRY_INVALID</span> An indication that a given entry is not a valid tar archive entry, and will be skipped. This occurs when:</p><ul>
<li>a checksum fails,</li>
<li>a <span class="tt">linkpath</span> is missing for a link type, or</li>
<li>a <span class="tt">linkpath</span> is provided for a non-link type.</li>
</ul>
<p class="startli">If every entry in a parsed archive raises an <span class="tt">TAR_ENTRY_INVALID</span> error, then the archive is presumed to be unrecoverably broken, and <span class="tt">TAR_BAD_ARCHIVE</span> will be raised.</p>
</li>
<li><span class="tt">TAR_ENTRY_ERROR</span> The entry appears to be a valid tar archive entry, but encountered an error which prevented it from being unpacked. This occurs when:<ul>
<li>an unrecoverable fs error happens during unpacking,</li>
<li>an entry is trying to extract into an excessively deep location (by default, limited to 1024 subfolders),</li>
<li>an entry has <span class="tt">..</span> in the path and <span class="tt">preservePaths</span> is not set, or</li>
<li>an entry is extracting through a symbolic link, when <span class="tt">preservePaths</span> is not set.</li>
</ul>
</li>
<li><span class="tt">TAR_ENTRY_UNSUPPORTED</span> An indication that a given entry is a valid archive entry, but of a type that is unsupported, and so will be skipped in archive creation or extracting.</li>
<li><span class="tt">TAR_ABORT</span> When parsing gzipped-encoded archives, the parser will abort the parse process raise a warning for any zlib errors encountered. Aborts are considered unrecoverable for both parsing and unpacking.</li>
<li><p class="startli"><span class="tt">TAR_BAD_ARCHIVE</span> The archive file is totally hosed. This can happen for a number of reasons, and always occurs at the end of a parse or extract:</p><ul>
<li>An entry body was truncated before seeing the full number of bytes.</li>
<li>The archive contained only invalid entries, indicating that it is likely not an archive, or at least, not an archive this library can parse.</li>
</ul>
<p class="startli"><span class="tt">TAR_BAD_ARCHIVE</span> is considered informative for parse operations, but unrecoverable for extraction. Note that, if encountered at the end of an extraction, tar WILL still have extracted as much it could from the archive, so there may be some garbage files to clean up.</p>
</li>
</ul>
<p>Errors that occur deeper in the system (ie, either the filesystem or zlib) will have their error codes left intact, and a <span class="tt">tarCode</span> matching one of the above will be added to the warning metadata or the raised error object.</p>
<p>Errors generated by tar will have one of the above codes set as the <span class="tt">error.code</span> field as well, but since errors originating in zlib or fs will have their original codes, it's better to read <span class="tt">error.tarCode</span> if you wish to see how tar is handling the issue.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6562"></a>
Examples</h2>
<p>The API mimics the <span class="tt">tar(1)</span> command line functionality, with aliases for more human-readable option and function names. The goal is that if you know how to use <span class="tt">tar(1)</span> in Unix, then you know how to use <span class="tt">import('tar')</span> in JavaScript.</p>
<p>To replicate <span class="tt">tar czf my-tarball.tgz files and folders</span>, you'd do:</p>
<div class="fragment"><div class="line">import { create } from &#39;tar&#39;</div>
<div class="line">create(</div>
<div class="line">  {</div>
<div class="line">    gzip: &lt;true|gzip options&gt;,</div>
<div class="line">    file: &#39;my-tarball.tgz&#39;</div>
<div class="line">  },</div>
<div class="line">  [&#39;some&#39;, &#39;files&#39;, &#39;and&#39;, &#39;folders&#39;]</div>
<div class="line">).then(_ =&gt; { .. tarball has been created .. })</div>
</div><!-- fragment --><p>To replicate <span class="tt">tar cz files and folders &gt; my-tarball.tgz</span>, you'd do:</p>
<div class="fragment"><div class="line">// if you&#39;re familiar with the tar(1) cli flags, this can be nice</div>
<div class="line">import * as tar from &#39;tar&#39;</div>
<div class="line">tar.c(</div>
<div class="line">  {</div>
<div class="line">    // &#39;z&#39; is alias for &#39;gzip&#39; option</div>
<div class="line">    z: &lt;true|gzip options&gt;</div>
<div class="line">  },</div>
<div class="line">  [&#39;some&#39;, &#39;files&#39;, &#39;and&#39;, &#39;folders&#39;]</div>
<div class="line">).pipe(fs.createWriteStream(&#39;my-tarball.tgz&#39;))</div>
</div><!-- fragment --><p>To replicate <span class="tt">tar xf my-tarball.tgz</span> you'd do:</p>
<div class="fragment"><div class="line">tar.x( // or `tar.extract`</div>
<div class="line">  {</div>
<div class="line">    // or `file:`</div>
<div class="line">    f: &#39;my-tarball.tgz&#39;</div>
<div class="line">  }</div>
<div class="line">).then(_=&gt; { .. tarball has been dumped in cwd .. })</div>
</div><!-- fragment --><p>To replicate <span class="tt">cat my-tarball.tgz | tar x -C some-dir --strip=1</span>:</p>
<div class="fragment"><div class="line">fs.createReadStream(&#39;my-tarball.tgz&#39;).pipe(</div>
<div class="line">  tar.x({</div>
<div class="line">    strip: 1,</div>
<div class="line">    C: &#39;some-dir&#39;, // alias for cwd:&#39;some-dir&#39;, also ok</div>
<div class="line">  }),</div>
<div class="line">)</div>
</div><!-- fragment --><p>To replicate <span class="tt">tar tf my-tarball.tgz</span>, do this:</p>
<div class="fragment"><div class="line">tar.t({</div>
<div class="line">  file: &#39;my-tarball.tgz&#39;,</div>
<div class="line">  onReadEntry: entry =&gt; { .. do whatever with it .. }</div>
<div class="line">})</div>
</div><!-- fragment --><p>For example, to just get the list of filenames from an archive:</p>
<div class="fragment"><div class="line">const getEntryFilenames = async tarballFilename =&gt; {</div>
<div class="line">  const filenames = []</div>
<div class="line">  await tar.t({</div>
<div class="line">    file: tarballFilename,</div>
<div class="line">    onReadEntry: entry =&gt; filenames.push(entry.path),</div>
<div class="line">  })</div>
<div class="line">  return filenames</div>
<div class="line">}</div>
</div><!-- fragment --><p>To replicate <span class="tt">cat my-tarball.tgz | tar t</span> do:</p>
<div class="fragment"><div class="line">fs.createReadStream(&#39;my-tarball.tgz&#39;)</div>
<div class="line">  .pipe(tar.t())</div>
<div class="line">  .on(&#39;entry&#39;, entry =&gt; { .. do whatever with it .. })</div>
</div><!-- fragment --><p>To do anything synchronous, add <span class="tt">sync: true</span> to the options. Note that sync functions don't take a callback and don't return a promise. When the function returns, it's already done. Sync methods without a file argument return a sync stream, which flushes immediately. But, of course, it still won't be done until you <span class="tt">.end()</span> it.</p>
<div class="fragment"><div class="line">const getEntryFilenamesSync = tarballFilename =&gt; {</div>
<div class="line">  const filenames = []</div>
<div class="line">  tar.t({</div>
<div class="line">    file: tarballFilename,</div>
<div class="line">    onReadEntry: entry =&gt; filenames.push(entry.path),</div>
<div class="line">    sync: true,</div>
<div class="line">  })</div>
<div class="line">  return filenames</div>
<div class="line">}</div>
</div><!-- fragment --><p>To filter entries, add <span class="tt">filter: &lt;function&gt;</span> to the options. Tar-creating methods call the filter with <span class="tt">filter(path, stat)</span>. Tar-reading methods (including extraction) call the filter with <span class="tt">filter(path, entry)</span>. The filter is called in the <span class="tt">this</span>-context of the <span class="tt">Pack</span> or <span class="tt">Unpack</span> stream object.</p>
<p>The arguments list to <span class="tt">tar t</span> and <span class="tt">tar x</span> specify a list of filenames to extract or list, so they're equivalent to a filter that tests if the file is in the list.</p>
<p>For those who <em>aren't</em> fans of tar's single-character command names:</p>
<div class="fragment"><div class="line">tar.c === tar.create</div>
<div class="line">tar.r === tar.replace (appends to archive, file is required)</div>
<div class="line">tar.u === tar.update (appends if newer, file is required)</div>
<div class="line">tar.x === tar.extract</div>
<div class="line">tar.t === tar.list</div>
</div><!-- fragment --><p>Keep reading for all the command descriptions and options, as well as the low-level API that they are built on.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6563"></a>
tar.c(options, fileList, callback) [alias: tar.create]</h2>
<p>Create a tarball archive.</p>
<p>The <span class="tt">fileList</span> is an array of paths to add to the tarball. Adding a directory also adds its children recursively.</p>
<p>An entry in <span class="tt">fileList</span> that starts with an <span class="tt">@</span> symbol is a tar archive whose entries will be added. To add a file that starts with <span class="tt">@</span>, prepend it with <span class="tt">./</span>.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">file</span> Write the tarball archive to the specified filename. If this is specified, then the callback will be fired when the file has been written, and a promise will be returned that resolves when the file is written. If a filename is not specified, then a Readable Stream will be returned which will emit the file data. [Alias: <span class="tt">f</span>]</li>
<li><span class="tt">sync</span> Act synchronously. If this is set, then any provided file will be fully written after the call to <span class="tt">tar.c</span>. If this is set, and a file is not provided, then the resulting stream will already have the data ready to <span class="tt">read</span> or <span class="tt">emit('data')</span> as soon as you request it.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">cwd</span> The current working directory for creating the archive. Defaults to <span class="tt">process.cwd()</span>. [Alias: <span class="tt">C</span>]</li>
<li><span class="tt">prefix</span> A path portion to prefix onto the entries in the archive.</li>
<li><span class="tt">gzip</span> Set to any truthy value to create a gzipped archive, or an object with settings for <span class="tt">zlib.Gzip()</span> [Alias: <span class="tt">z</span>]</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, stat)</span> for each entry being added. Return <span class="tt">true</span> to add the entry to the archive, or <span class="tt">false</span> to omit it.</li>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths. [Alias: <span class="tt">P</span>]</li>
<li><span class="tt">mode</span> The mode to set on the created file archive</li>
<li><span class="tt">noDirRecurse</span> Do not recursively archive the contents of directories. [Alias: <span class="tt">n</span>]</li>
<li><span class="tt">follow</span> Set to true to pack the targets of symbolic links. Without this option, symbolic links are archived as such. [Alias: <span class="tt">L</span>, <span class="tt">h</span>]</li>
<li><span class="tt">noPax</span> Suppress pax extended headers. Note that this means that long paths and linkpaths will be truncated, and large or negative numeric values may be interpreted incorrectly.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive. [Alias: <span class="tt">m</span>, <span class="tt">no-mtime</span>]</li>
<li><span class="tt">mtime</span> Set to a <span class="tt">Date</span> object to force a specific <span class="tt">mtime</span> for everything added to the archive. Overridden by <span class="tt">noMtime</span>.</li>
<li><span class="tt">onWriteEntry</span> Called with each <span class="tt">WriteEntry</span> or <span class="tt">WriteEntrySync</span> that is created in the course of writing the archive.</li>
</ul>
<p>The following options are mostly internal, but can be modified in some advanced use cases, such as re-using caches between runs.</p>
<ul>
<li><span class="tt">linkCache</span> A Map object containing the device and inode value for any file whose nlink is &gt; 1, to identify hard links.</li>
<li><span class="tt">statCache</span> A Map object that caches calls <span class="tt">lstat</span>.</li>
<li><span class="tt">readdirCache</span> A Map object that caches calls to <span class="tt">readdir</span>.</li>
<li><span class="tt">jobs</span> A number specifying how many concurrent jobs to run. Defaults to 4.</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6564"></a>
tar.x(options, fileList, callback) [alias: tar.extract]</h2>
<p>Extract a tarball archive.</p>
<p>The <span class="tt">fileList</span> is an array of paths to extract from the tarball. If no paths are provided, then all the entries are extracted.</p>
<p>If the archive is gzipped, then tar will detect this and unzip it.</p>
<p>Note that all directories that are created will be forced to be writable, readable, and listable by their owner, to avoid cases where a directory prevents extraction of child entries by virtue of its mode.</p>
<p>Most extraction errors will cause a <span class="tt">warn</span> event to be emitted. If the <span class="tt">cwd</span> is missing, or not a directory, then the extraction will fail completely.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">cwd</span> Extract files relative to the specified directory. Defaults to <span class="tt">process.cwd()</span>. If provided, this must exist and must be a directory. [Alias: <span class="tt">C</span>]</li>
<li><span class="tt">file</span> The archive file to extract. If not specified, then a Writable stream is returned where the archive data should be written. [Alias: <span class="tt">f</span>]</li>
<li><span class="tt">sync</span> Create files and directories synchronously.</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, entry)</span> for each entry being unpacked. Return <span class="tt">true</span> to unpack the entry from the archive, or <span class="tt">false</span> to skip it.</li>
<li><span class="tt">newer</span> Set to true to keep the existing file on disk if it's newer than the file in the archive. [Alias: <span class="tt">keep-newer</span>, <span class="tt">keep-newer-files</span>]</li>
<li><span class="tt">keep</span> Do not overwrite existing files. In particular, if a file appears more than once in an archive, later copies will not overwrite earlier copies. [Alias: <span class="tt">k</span>, <span class="tt">keep-existing</span>]</li>
<li><span class="tt">preservePaths</span> Allow absolute paths, paths containing <span class="tt">..</span>, and extracting through symbolic links. By default, <span class="tt">/</span> is stripped from absolute paths, <span class="tt">..</span> paths are not extracted, and any file whose location would be modified by a symbolic link is not extracted. [Alias: <span class="tt">P</span>]</li>
<li><span class="tt">unlink</span> Unlink files before creating them. Without this option, tar overwrites existing files, which preserves existing hardlinks. With this option, existing hardlinks will be broken, as will any symlink that would affect the location of an extracted file. [Alias: <span class="tt">U</span>]</li>
<li><span class="tt">strip</span> Remove the specified number of leading path elements. Pathnames with fewer elements will be silently skipped. Note that the pathname is edited after applying the filter, but before security checks. [Alias: <span class="tt">strip-components</span>, <span class="tt">stripComponents</span>]</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">preserveOwner</span> If true, tar will set the <span class="tt">uid</span> and <span class="tt">gid</span> of extracted entries to the <span class="tt">uid</span> and <span class="tt">gid</span> fields in the archive. This defaults to true when run as root, and false otherwise. If false, then files and directories will be set with the owner and group of the user running the process. This is similar to <span class="tt">-p</span> in <span class="tt">tar(1)</span>, but ACLs and other system-specific data is never unpacked in this implementation, and modes are set by default already. [Alias: <span class="tt">p</span>]</li>
<li><span class="tt">uid</span> Set to a number to force ownership of all extracted files and folders, and all implicitly created directories, to be owned by the specified user id, regardless of the <span class="tt">uid</span> field in the archive. Cannot be used along with <span class="tt">preserveOwner</span>. Requires also setting a <span class="tt">gid</span> option.</li>
<li><span class="tt">gid</span> Set to a number to force ownership of all extracted files and folders, and all implicitly created directories, to be owned by the specified group id, regardless of the <span class="tt">gid</span> field in the archive. Cannot be used along with <span class="tt">preserveOwner</span>. Requires also setting a <span class="tt">uid</span> option.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> value for extracted entries. [Alias: <span class="tt">m</span>, <span class="tt">no-mtime</span>]</li>
<li><span class="tt">transform</span> Provide a function that takes an <span class="tt">entry</span> object, and returns a stream, or any falsey value. If a stream is provided, then that stream's data will be written instead of the contents of the archive entry. If a falsey value is provided, then the entry is written to disk as normal. (To exclude items from extraction, use the <span class="tt">filter</span> option described above.)</li>
<li><span class="tt">onReadEntry</span> A function that gets called with <span class="tt">(entry)</span> for each entry that passes the filter.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">chmod</span> Set to true to call <span class="tt">fs.chmod()</span> to ensure that the extracted file matches the entry mode. This may necessitate a call to the deprecated and thread-unsafe <span class="tt">process.umask()</span> method to determine the default umask value, unless a <span class="tt">processUmask</span> options is also provided. Otherwise tar will extract with whatever mode is provided, and let the process <span class="tt">umask</span> apply normally.</li>
<li><span class="tt">processUmask</span> Set to an explicit numeric value to avoid calling <span class="tt">process.umask()</span> when <span class="tt">chmod: true</span> is set.</li>
<li><span class="tt">maxDepth</span> The maximum depth of subfolders to extract into. This defaults to 1024. Anything deeper than the limit will raise a warning and skip the entry. Set to <span class="tt">Infinity</span> to remove the limitation.</li>
</ul>
<p>The following options are mostly internal, but can be modified in some advanced use cases, such as re-using caches between runs.</p>
<ul>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
<li><span class="tt">umask</span> Filter the modes of entries like <span class="tt">process.umask()</span>.</li>
<li><span class="tt">dmode</span> Default mode for directories</li>
<li><span class="tt">fmode</span> Default mode for files</li>
<li><span class="tt">dirCache</span> A Map object of which directories exist.</li>
<li><span class="tt">maxMetaEntrySize</span> The maximum size of meta entries that is supported. Defaults to 1 MB.</li>
</ul>
<p>Note that using an asynchronous stream type with the <span class="tt">transform</span> option will cause undefined behavior in sync extractions. <a href="http://npm.im/minipass">MiniPass</a>-based streams are designed for this use case.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6565"></a>
tar.t(options, fileList, callback) [alias: tar.list]</h2>
<p>List the contents of a tarball archive.</p>
<p>The <span class="tt">fileList</span> is an array of paths to list from the tarball. If no paths are provided, then all the entries are listed.</p>
<p>If the archive is gzipped, then tar will detect this and unzip it.</p>
<p>If the <span class="tt">file</span> option is <em>not</em> provided, then returns an event emitter that emits <span class="tt">entry</span> events with <span class="tt">tar.ReadEntry</span> objects. However, they don't emit <span class="tt">'data'</span> or <span class="tt">'end'</span> events. (If you want to get actual readable entries, use the <span class="tt">tar.Parse</span> class instead.)</p>
<p>If a <span class="tt">file</span> option <em>is</em> provided, then the return value will be a promise that resolves when the file has been fully traversed in async mode, or <span class="tt">undefined</span> if <span class="tt">sync: true</span> is set. Thus, you <em>must</em> specify an <span class="tt">onReadEntry</span> method in order to do anything useful with the data it parses.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">file</span> The archive file to list. If not specified, then a Writable stream is returned where the archive data should be written. [Alias: <span class="tt">f</span>]</li>
<li><span class="tt">sync</span> Read the specified file synchronously. (This has no effect when a file option isn't specified, because entries are emitted as fast as they are parsed from the stream anyway.)</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, entry)</span> for each entry being listed. Return <span class="tt">true</span> to emit the entry from the archive, or <span class="tt">false</span> to skip it.</li>
<li><span class="tt">onReadEntry</span> A function that gets called with <span class="tt">(entry)</span> for each entry that passes the filter. This is important for when <span class="tt">file</span> is set, because there is no other way to do anything useful with this method.</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
<li><span class="tt">noResume</span> By default, <span class="tt">entry</span> streams are resumed immediately after the call to <span class="tt">onReadEntry</span>. Set <span class="tt">noResume: true</span> to suppress this behavior. Note that by opting into this, the stream will never complete until the entry data is consumed.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6566"></a>
tar.u(options, fileList, callback) [alias: tar.update]</h2>
<p>Add files to an archive if they are newer than the entry already in the tarball archive.</p>
<p>The <span class="tt">fileList</span> is an array of paths to add to the tarball. Adding a directory also adds its children recursively.</p>
<p>An entry in <span class="tt">fileList</span> that starts with an <span class="tt">@</span> symbol is a tar archive whose entries will be added. To add a file that starts with <span class="tt">@</span>, prepend it with <span class="tt">./</span>.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">file</span> Required. Write the tarball archive to the specified filename. [Alias: <span class="tt">f</span>]</li>
<li><span class="tt">sync</span> Act synchronously. If this is set, then any provided file will be fully written after the call to <span class="tt">tar.c</span>.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">cwd</span> The current working directory for adding entries to the archive. Defaults to <span class="tt">process.cwd()</span>. [Alias: <span class="tt">C</span>]</li>
<li><span class="tt">prefix</span> A path portion to prefix onto the entries in the archive.</li>
<li><span class="tt">gzip</span> Set to any truthy value to create a gzipped archive, or an object with settings for <span class="tt">zlib.Gzip()</span> [Alias: <span class="tt">z</span>]</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, stat)</span> for each entry being added. Return <span class="tt">true</span> to add the entry to the archive, or <span class="tt">false</span> to omit it.</li>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths. [Alias: <span class="tt">P</span>]</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
<li><span class="tt">noDirRecurse</span> Do not recursively archive the contents of directories. [Alias: <span class="tt">n</span>]</li>
<li><span class="tt">follow</span> Set to true to pack the targets of symbolic links. Without this option, symbolic links are archived as such. [Alias: <span class="tt">L</span>, <span class="tt">h</span>]</li>
<li><span class="tt">noPax</span> Suppress pax extended headers. Note that this means that long paths and linkpaths will be truncated, and large or negative numeric values may be interpreted incorrectly.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive. [Alias: <span class="tt">m</span>, <span class="tt">no-mtime</span>]</li>
<li><span class="tt">mtime</span> Set to a <span class="tt">Date</span> object to force a specific <span class="tt">mtime</span> for everything added to the archive. Overridden by <span class="tt">noMtime</span>.</li>
<li><span class="tt">onWriteEntry</span> Called with each <span class="tt">WriteEntry</span> or <span class="tt">WriteEntrySync</span> that is created in the course of writing the archive.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6567"></a>
tar.r(options, fileList, callback) [alias: tar.replace]</h2>
<p>Add files to an existing archive. Because later entries override earlier entries, this effectively replaces any existing entries.</p>
<p>The <span class="tt">fileList</span> is an array of paths to add to the tarball. Adding a directory also adds its children recursively.</p>
<p>An entry in <span class="tt">fileList</span> that starts with an <span class="tt">@</span> symbol is a tar archive whose entries will be added. To add a file that starts with <span class="tt">@</span>, prepend it with <span class="tt">./</span>.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">file</span> Required. Write the tarball archive to the specified filename. [Alias: <span class="tt">f</span>]</li>
<li><span class="tt">sync</span> Act synchronously. If this is set, then any provided file will be fully written after the call to <span class="tt">tar.c</span>.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">cwd</span> The current working directory for adding entries to the archive. Defaults to <span class="tt">process.cwd()</span>. [Alias: <span class="tt">C</span>]</li>
<li><span class="tt">prefix</span> A path portion to prefix onto the entries in the archive.</li>
<li><span class="tt">gzip</span> Set to any truthy value to create a gzipped archive, or an object with settings for <span class="tt">zlib.Gzip()</span> [Alias: <span class="tt">z</span>]</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, stat)</span> for each entry being added. Return <span class="tt">true</span> to add the entry to the archive, or <span class="tt">false</span> to omit it.</li>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths. [Alias: <span class="tt">P</span>]</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
<li><span class="tt">noDirRecurse</span> Do not recursively archive the contents of directories. [Alias: <span class="tt">n</span>]</li>
<li><span class="tt">follow</span> Set to true to pack the targets of symbolic links. Without this option, symbolic links are archived as such. [Alias: <span class="tt">L</span>, <span class="tt">h</span>]</li>
<li><span class="tt">noPax</span> Suppress pax extended headers. Note that this means that long paths and linkpaths will be truncated, and large or negative numeric values may be interpreted incorrectly.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive. [Alias: <span class="tt">m</span>, <span class="tt">no-mtime</span>]</li>
<li><span class="tt">mtime</span> Set to a <span class="tt">Date</span> object to force a specific <span class="tt">mtime</span> for everything added to the archive. Overridden by <span class="tt">noMtime</span>.</li>
<li><span class="tt">onWriteEntry</span> Called with each <span class="tt">WriteEntry</span> or <span class="tt">WriteEntrySync</span> that is created in the course of writing the archive.</li>
</ul>
<h1 class="doxsection"><a class="anchor" id="autotoc_md6568"></a>
Low-Level API</h1>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6569"></a>
class Pack</h2>
<p>A readable tar stream.</p>
<p>Has all the standard readable stream interface stuff. <span class="tt">'data'</span> and <span class="tt">'end'</span> events, <span class="tt">read()</span> method, <span class="tt">pause()</span> and <span class="tt">resume()</span>, etc.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6570"></a>
constructor(options)</h3>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">cwd</span> The current working directory for creating the archive. Defaults to <span class="tt">process.cwd()</span>.</li>
<li><span class="tt">prefix</span> A path portion to prefix onto the entries in the archive.</li>
<li><span class="tt">gzip</span> Set to any truthy value to create a gzipped archive, or an object with settings for <span class="tt">zlib.Gzip()</span></li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, stat)</span> for each entry being added. Return <span class="tt">true</span> to add the entry to the archive, or <span class="tt">false</span> to omit it.</li>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths.</li>
<li><span class="tt">linkCache</span> A Map object containing the device and inode value for any file whose nlink is &gt; 1, to identify hard links.</li>
<li><span class="tt">statCache</span> A Map object that caches calls <span class="tt">lstat</span>.</li>
<li><span class="tt">readdirCache</span> A Map object that caches calls to <span class="tt">readdir</span>.</li>
<li><span class="tt">jobs</span> A number specifying how many concurrent jobs to run. Defaults to 4.</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 16 MB.</li>
<li><span class="tt">noDirRecurse</span> Do not recursively archive the contents of directories.</li>
<li><span class="tt">follow</span> Set to true to pack the targets of symbolic links. Without this option, symbolic links are archived as such.</li>
<li><span class="tt">noPax</span> Suppress pax extended headers. Note that this means that long paths and linkpaths will be truncated, and large or negative numeric values may be interpreted incorrectly.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive.</li>
<li><span class="tt">mtime</span> Set to a <span class="tt">Date</span> object to force a specific <span class="tt">mtime</span> for everything added to the archive. Overridden by <span class="tt">noMtime</span>.</li>
<li><span class="tt">onWriteEntry</span> Called with each <span class="tt">WriteEntry</span> or <span class="tt">WriteEntrySync</span> that is created in the course of writing the archive.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6571"></a>
add(path)</h3>
<p>Adds an entry to the archive. Returns the Pack stream.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6572"></a>
write(path)</h3>
<p>Adds an entry to the archive. Returns true if flushed.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6573"></a>
end()</h3>
<p>Finishes the archive.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6574"></a>
class PackSync</h2>
<p>Synchronous version of <span class="tt">Pack</span>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6575"></a>
class Unpack</h2>
<p>A writable stream that unpacks a tar archive onto the file system.</p>
<p>All the normal writable stream stuff is supported. <span class="tt">write()</span> and <span class="tt">end()</span> methods, <span class="tt">'drain'</span> events, etc.</p>
<p>Note that all directories that are created will be forced to be writable, readable, and listable by their owner, to avoid cases where a directory prevents extraction of child entries by virtue of its mode.</p>
<p><span class="tt">'close'</span> is emitted when it's done writing stuff to the file system.</p>
<p>Most unpack errors will cause a <span class="tt">warn</span> event to be emitted. If the <span class="tt">cwd</span> is missing, or not a directory, then an error will be emitted.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6576"></a>
constructor(options)</h3>
<ul>
<li><span class="tt">cwd</span> Extract files relative to the specified directory. Defaults to <span class="tt">process.cwd()</span>. If provided, this must exist and must be a directory.</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, entry)</span> for each entry being unpacked. Return <span class="tt">true</span> to unpack the entry from the archive, or <span class="tt">false</span> to skip it.</li>
<li><span class="tt">newer</span> Set to true to keep the existing file on disk if it's newer than the file in the archive.</li>
<li><span class="tt">keep</span> Do not overwrite existing files. In particular, if a file appears more than once in an archive, later copies will not overwrite earlier copies.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths, paths containing <span class="tt">..</span>, and extracting through symbolic links. By default, <span class="tt">/</span> is stripped from absolute paths, <span class="tt">..</span> paths are not extracted, and any file whose location would be modified by a symbolic link is not extracted.</li>
<li><span class="tt">unlink</span> Unlink files before creating them. Without this option, tar overwrites existing files, which preserves existing hardlinks. With this option, existing hardlinks will be broken, as will any symlink that would affect the location of an extracted file.</li>
<li><span class="tt">strip</span> Remove the specified number of leading path elements. Pathnames with fewer elements will be silently skipped. Note that the pathname is edited after applying the filter, but before security checks.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">umask</span> Filter the modes of entries like <span class="tt">process.umask()</span>.</li>
<li><span class="tt">dmode</span> Default mode for directories</li>
<li><span class="tt">fmode</span> Default mode for files</li>
<li><span class="tt">dirCache</span> A Map object of which directories exist.</li>
<li><span class="tt">maxMetaEntrySize</span> The maximum size of meta entries that is supported. Defaults to 1 MB.</li>
<li><span class="tt">preserveOwner</span> If true, tar will set the <span class="tt">uid</span> and <span class="tt">gid</span> of extracted entries to the <span class="tt">uid</span> and <span class="tt">gid</span> fields in the archive. This defaults to true when run as root, and false otherwise. If false, then files and directories will be set with the owner and group of the user running the process. This is similar to <span class="tt">-p</span> in <span class="tt">tar(1)</span>, but ACLs and other system-specific data is never unpacked in this implementation, and modes are set by default already.</li>
<li><span class="tt">win32</span> True if on a windows platform. Causes behavior where filenames containing <span class="tt">&lt;|&gt;?</span> chars are converted to windows-compatible values while being unpacked.</li>
<li><span class="tt">uid</span> Set to a number to force ownership of all extracted files and folders, and all implicitly created directories, to be owned by the specified user id, regardless of the <span class="tt">uid</span> field in the archive. Cannot be used along with <span class="tt">preserveOwner</span>. Requires also setting a <span class="tt">gid</span> option.</li>
<li><span class="tt">gid</span> Set to a number to force ownership of all extracted files and folders, and all implicitly created directories, to be owned by the specified group id, regardless of the <span class="tt">gid</span> field in the archive. Cannot be used along with <span class="tt">preserveOwner</span>. Requires also setting a <span class="tt">uid</span> option.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> value for extracted entries.</li>
<li><span class="tt">transform</span> Provide a function that takes an <span class="tt">entry</span> object, and returns a stream, or any falsey value. If a stream is provided, then that stream's data will be written instead of the contents of the archive entry. If a falsey value is provided, then the entry is written to disk as normal. (To exclude items from extraction, use the <span class="tt">filter</span> option described above.)</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">onReadEntry</span> A function that gets called with <span class="tt">(entry)</span> for each entry that passes the filter.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">chmod</span> Set to true to call <span class="tt">fs.chmod()</span> to ensure that the extracted file matches the entry mode. This may necessitate a call to the deprecated and thread-unsafe <span class="tt">process.umask()</span> method to determine the default umask value, unless a <span class="tt">processUmask</span> options is also provided. Otherwise tar will extract with whatever mode is provided, and let the process <span class="tt">umask</span> apply normally.</li>
<li><span class="tt">processUmask</span> Set to an explicit numeric value to avoid calling <span class="tt">process.umask()</span> when <span class="tt">chmod: true</span> is set.</li>
<li><span class="tt">maxDepth</span> The maximum depth of subfolders to extract into. This defaults to 1024. Anything deeper than the limit will raise a warning and skip the entry. Set to <span class="tt">Infinity</span> to remove the limitation.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6577"></a>
class UnpackSync</h2>
<p>Synchronous version of <span class="tt">Unpack</span>.</p>
<p>Note that using an asynchronous stream type with the <span class="tt">transform</span> option will cause undefined behavior in sync unpack streams. <a href="http://npm.im/minipass">MiniPass</a>-based streams are designed for this use case.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6578"></a>
class tar.Parse</h2>
<p>A writable stream that parses a tar archive stream. All the standard writable stream stuff is supported.</p>
<p>If the archive is gzipped, then tar will detect this and unzip it.</p>
<p>Emits <span class="tt">'entry'</span> events with <span class="tt">tar.ReadEntry</span> objects, which are themselves readable streams that you can pipe wherever.</p>
<p>Each <span class="tt">entry</span> will not emit until the one before it is flushed through, so make sure to either consume the data (with <span class="tt">on('data', ...)</span> or <span class="tt">.pipe(...)</span>) or throw it away with <span class="tt">.resume()</span> to keep the stream flowing.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6579"></a>
constructor(options)</h3>
<p>Returns an event emitter that emits <span class="tt">entry</span> events with <span class="tt">tar.ReadEntry</span> objects.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">filter</span> A function that gets called with <span class="tt">(path, entry)</span> for each entry being listed. Return <span class="tt">true</span> to emit the entry from the archive, or <span class="tt">false</span> to skip it.</li>
<li><span class="tt">onReadEntry</span> A function that gets called with <span class="tt">(entry)</span> for each entry that passes the filter.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6580"></a>
abort(error)</h3>
<p>Stop all parsing activities. This is called when there are zlib errors. It also emits an unrecoverable warning with the error provided.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6581"></a>
class tar.ReadEntry extends <a href="http://npm.im/minipass">MiniPass</a></h2>
<p>A representation of an entry that is being read out of a tar archive.</p>
<p>It has the following fields:</p>
<ul>
<li><span class="tt">extended</span> The extended metadata object provided to the constructor.</li>
<li><span class="tt">globalExtended</span> The global extended metadata object provided to the constructor.</li>
<li><span class="tt">remain</span> The number of bytes remaining to be written into the stream.</li>
<li><span class="tt">blockRemain</span> The number of 512-byte blocks remaining to be written into the stream.</li>
<li><span class="tt">ignore</span> Whether this entry should be ignored.</li>
<li><span class="tt">meta</span> True if this represents metadata about the next entry, false if it represents a filesystem object.</li>
<li>All the fields from the header, extended header, and global extended header are added to the ReadEntry object. So it has <span class="tt">path</span>, <span class="tt">type</span>, <span class="tt">size</span>, <span class="tt">mode</span>, and so on.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6582"></a>
constructor(header, extended, globalExtended)</h3>
<p>Create a new ReadEntry object with the specified header, extended header, and global extended header values.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6583"></a>
class tar.WriteEntry extends <a href="http://npm.im/minipass">MiniPass</a></h2>
<p>A representation of an entry that is being written from the file system into a tar archive.</p>
<p>Emits data for the Header, and for the Pax Extended Header if one is required, as well as any body data.</p>
<p>Creating a WriteEntry for a directory does not also create WriteEntry objects for all of the directory contents.</p>
<p>It has the following fields:</p>
<ul>
<li><span class="tt">path</span> The path field that will be written to the archive. By default, this is also the path from the cwd to the file system object.</li>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">myuid</span> If supported, the uid of the user running the current process.</li>
<li><span class="tt">myuser</span> The <span class="tt">env.USER</span> string if set, or <span class="tt">''</span>. Set as the entry <span class="tt">uname</span> field if the file's <span class="tt">uid</span> matches <span class="tt">this.myuid</span>.</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 1 MB.</li>
<li><span class="tt">linkCache</span> A Map object containing the device and inode value for any file whose nlink is &gt; 1, to identify hard links.</li>
<li><span class="tt">statCache</span> A Map object that caches calls <span class="tt">lstat</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths.</li>
<li><span class="tt">cwd</span> The current working directory for creating the archive. Defaults to <span class="tt">process.cwd()</span>.</li>
<li><span class="tt">absolute</span> The absolute path to the entry on the filesystem. By default, this is <span class="tt">path.resolve(this.cwd, this.path)</span>, but it can be overridden explicitly.</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">win32</span> True if on a windows platform. Causes behavior where paths replace <span class="tt">\</span> with <span class="tt">/</span> and filenames containing the windows-compatible forms of <span class="tt">&lt;|&gt;?:</span> characters are converted to actual <span class="tt">&lt;|&gt;?:</span> characters in the archive.</li>
<li><span class="tt">noPax</span> Suppress pax extended headers. Note that this means that long paths and linkpaths will be truncated, and large or negative numeric values may be interpreted incorrectly.</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6584"></a>
constructor(path, options)</h3>
<p><span class="tt">path</span> is the path of the entry as it is written in the archive.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">maxReadSize</span> The maximum buffer size for <span class="tt">fs.read()</span> operations. Defaults to 1 MB.</li>
<li><span class="tt">linkCache</span> A Map object containing the device and inode value for any file whose nlink is &gt; 1, to identify hard links.</li>
<li><span class="tt">statCache</span> A Map object that caches calls <span class="tt">lstat</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths.</li>
<li><span class="tt">cwd</span> The current working directory for creating the archive. Defaults to <span class="tt">process.cwd()</span>.</li>
<li><span class="tt">absolute</span> The absolute path to the entry on the filesystem. By default, this is <span class="tt">path.resolve(this.cwd, this.path)</span>, but it can be overridden explicitly.</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">win32</span> True if on a windows platform. Causes behavior where paths replace <span class="tt">\</span> with <span class="tt">/</span>.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive.</li>
<li><span class="tt">umask</span> Set to restrict the modes on the entries in the archive, somewhat like how umask works on file creation. Defaults to <span class="tt">process.umask()</span> on unix systems, or <span class="tt">0o22</span> on Windows.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6585"></a>
warn(message, data)</h3>
<p>If strict, emit an error with the provided message.</p>
<p>Othewise, emit a <span class="tt">'warn'</span> event with the provided message and data.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6586"></a>
class tar.WriteEntry.Sync</h2>
<p>Synchronous version of tar.WriteEntry</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6587"></a>
class tar.WriteEntry.Tar</h2>
<p>A version of tar.WriteEntry that gets its data from a tar.ReadEntry instead of from the filesystem.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6588"></a>
constructor(readEntry, options)</h3>
<p><span class="tt">readEntry</span> is the entry being read out of another archive.</p>
<p>The following options are supported:</p>
<ul>
<li><span class="tt">portable</span> Omit metadata that is system-specific: <span class="tt">ctime</span>, <span class="tt">atime</span>, <span class="tt">uid</span>, <span class="tt">gid</span>, <span class="tt">uname</span>, <span class="tt">gname</span>, <span class="tt">dev</span>, <span class="tt">ino</span>, and <span class="tt">nlink</span>. Note that <span class="tt">mtime</span> is still included, because this is necessary for other time-based operations. Additionally, <span class="tt">mode</span> is set to a "reasonable
  default" for most unix systems, based on a <span class="tt">umask</span> value of <span class="tt">0o22</span>.</li>
<li><span class="tt">preservePaths</span> Allow absolute paths. By default, <span class="tt">/</span> is stripped from absolute paths.</li>
<li><span class="tt">strict</span> Treat warnings as crash-worthy errors. Default false.</li>
<li><span class="tt">onwarn</span> A function that will get called with <span class="tt">(code, message, data)</span> for any warnings encountered. (See "Warnings and Errors")</li>
<li><span class="tt">noMtime</span> Set to true to omit writing <span class="tt">mtime</span> values for entries. Note that this prevents using other mtime-based features like <span class="tt">tar.update</span> or the <span class="tt">keepNewer</span> option with the resulting tar archive.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6589"></a>
class tar.Header</h2>
<p>A class for reading and writing header blocks.</p>
<p>It has the following fields:</p>
<ul>
<li><span class="tt">nullBlock</span> True if decoding a block which is entirely composed of <span class="tt">0x00</span> null bytes. (Useful because tar files are terminated by at least 2 null blocks.)</li>
<li><span class="tt">cksumValid</span> True if the checksum in the header is valid, false otherwise.</li>
<li><span class="tt">needPax</span> True if the values, as encoded, will require a Pax extended header.</li>
<li><span class="tt">path</span> The path of the entry.</li>
<li><span class="tt">mode</span> The 4 lowest-order octal digits of the file mode. That is, read/write/execute permissions for world, group, and owner, and the setuid, setgid, and sticky bits.</li>
<li><span class="tt">uid</span> Numeric user id of the file owner</li>
<li><span class="tt">gid</span> Numeric group id of the file owner</li>
<li><span class="tt">size</span> Size of the file in bytes</li>
<li><span class="tt">mtime</span> Modified time of the file</li>
<li><span class="tt">cksum</span> The checksum of the header. This is generated by adding all the bytes of the header block, treating the checksum field itself as all ascii space characters (that is, <span class="tt">0x20</span>).</li>
<li><span class="tt">type</span> The human-readable name of the type of entry this represents, or the alphanumeric key if unknown.</li>
<li><span class="tt">typeKey</span> The alphanumeric key for the type of entry this header represents.</li>
<li><span class="tt">linkpath</span> The target of Link and SymbolicLink entries.</li>
<li><span class="tt">uname</span> Human-readable user name of the file owner</li>
<li><span class="tt">gname</span> Human-readable group name of the file owner</li>
<li><span class="tt">devmaj</span> The major portion of the device number. Always <span class="tt">0</span> for files, directories, and links.</li>
<li><span class="tt">devmin</span> The minor portion of the device number. Always <span class="tt">0</span> for files, directories, and links.</li>
<li><span class="tt">atime</span> File access time.</li>
<li><span class="tt">ctime</span> File change time.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6590"></a>
constructor(data, [offset=0])</h3>
<p><span class="tt">data</span> is optional. It is either a Buffer that should be interpreted as a tar Header starting at the specified offset and continuing for 512 bytes, or a data object of keys and values to set on the header object, and eventually encode as a tar Header.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6591"></a>
decode(block, offset)</h3>
<p>Decode the provided buffer starting at the specified offset.</p>
<p>Buffer length must be greater than 512 bytes.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6592"></a>
set(data)</h3>
<p>Set the fields in the data object.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6593"></a>
encode(buffer, offset)</h3>
<p>Encode the header fields into the buffer at the specified offset.</p>
<p>Returns <span class="tt">this.needPax</span> to indicate whether a Pax Extended Header is required to properly encode the specified data.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6594"></a>
class tar.Pax</h2>
<p>An object representing a set of key-value pairs in an Pax extended header entry.</p>
<p>It has the following fields. Where the same name is used, they have the same semantics as the tar.Header field of the same name.</p>
<ul>
<li><span class="tt">global</span> True if this represents a global extended header, or false if it is for a single entry.</li>
<li><span class="tt">atime</span></li>
<li><span class="tt">charset</span></li>
<li><span class="tt">comment</span></li>
<li><span class="tt">ctime</span></li>
<li><span class="tt">gid</span></li>
<li><span class="tt">gname</span></li>
<li><span class="tt">linkpath</span></li>
<li><span class="tt">mtime</span></li>
<li><span class="tt">path</span></li>
<li><span class="tt">size</span></li>
<li><span class="tt">uid</span></li>
<li><span class="tt">uname</span></li>
<li><span class="tt">dev</span></li>
<li><span class="tt">ino</span></li>
<li><span class="tt">nlink</span></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6595"></a>
constructor(object, global)</h3>
<p>Set the fields set in the object. <span class="tt">global</span> is a boolean that defaults to false.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6596"></a>
encode()</h3>
<p>Return a Buffer containing the header and body for the Pax extended header entry, or <span class="tt">null</span> if there is nothing to encode.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6597"></a>
encodeBody()</h3>
<p>Return a string representing the body of the pax extended header entry.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6598"></a>
encodeField(fieldName)</h3>
<p>Return a string representing the key/value encoding for the specified fieldName, or <span class="tt">''</span> if the field is unset.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6599"></a>
tar.Pax.parse(string, extended, global)</h2>
<p>Return a new Pax object created by parsing the contents of the string provided.</p>
<p>If the <span class="tt">extended</span> object is set, then also add the fields from that object. (This is necessary because multiple metadata entries can occur in sequence.)</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md6600"></a>
tar.types</h2>
<p>A translation table for the <span class="tt">type</span> field in tar headers.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6601"></a>
tar.types.name.get(code)</h3>
<p>Get the human-readable name for a given alphanumeric code.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md6602"></a>
tar.types.code.get(name)</h3>
<p>Get the alphanumeric code for a given human-readable name. </p>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a href="dir_b0ffaa9650680648f71633623b80e4c9.html">Eunice</a></li><li class="navelem"><a href="dir_06a7aea77c9c918e297ef6ec7ffe0f68.html">frontend</a></li><li class="navelem"><b>node_modules</b></li><li class="navelem"><a href="dir_923c113b0a7a79553d4f783153263068.html">tar</a></li>
    <li class="footer">Generated on <span class="timestamp"></span> for ACP - Autonomous Command Protocol by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.15.0 </li>
  </ul>
</div>
</body>
</html>
